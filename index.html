<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sideline Timekeeper</title>
<style>
  :root {
    --bg: #0b1220; --panel: #101a32; --ink: #e6eefc; --muted:#9fb0d1;
    --accent:#4ea1ff; --ok:#24c88b; --under:#ffb020; --over:#ff6b6b;
    --warn:#ffd166; --line:#1f2c4d;
  }
  * { box-sizing: border-box; }
  html, body { margin:0; height:100%; background:var(--bg); color:var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  header { padding: 12px 16px; background: #0a142a; border-bottom:1px solid var(--line); display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  header h1 { font-size: 18px; margin:0; font-weight:700; }
  header .grow { flex:1; }
  .btn {
    appearance:none; border:1px solid var(--line); background:#0e1a36; color:var(--ink);
    padding:8px 12px; border-radius:8px; font-weight:600; cursor:pointer;
  }
  .btn.primary { background:var(--accent); color:#001933; border-color:#2a81e0; }
  .btn.warn { background:var(--warn); color:#1b1400; border-color:#caa94a; }
  .btn.ghost { background:transparent; }
  .btn:disabled { opacity:.5; cursor:not-allowed; }
  .toolbar { display:flex; gap:8px; flex-wrap:wrap; }
  .wrap { padding:12px; display:flex; gap:12px; flex-direction:column; }
  .panel { background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:12px; }
  .grid { display:grid; gap:12px; }
  @media (min-width: 960px) {
    .grid.cols-2 { grid-template-columns: 1fr 1fr; }
    .grid.cols-3 { grid-template-columns: 1fr 1fr 1fr; }
  }
  .section-title { font-size:14px; color:var(--muted); margin-bottom:8px; text-transform:uppercase; letter-spacing:.06em; }
  input, select, textarea {
    width:100%; background:#0b1530; border:1px solid var(--line); color:var(--ink);
    padding:8px; border-radius:8px;
  }
  textarea { min-height: 160px; }
  table { width:100%; border-collapse: collapse; }
  th, td { text-align:left; padding:8px; border-bottom: 1px solid var(--line); font-size:14px; }
  th { color: var(--muted); font-weight:600; }
  tr:hover td { background:#0c1732; }
  .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--line); font-size:12px; color:var(--muted); }
  .status-in { background:#0b2a17; color:#b6f2ce; border-color:#1f5030; }
  .status-out { background:#2a0b0b; color:#f2b6b6; border-color:#502323; }
  .fair.ok { color: var(--ok); font-weight:700; }
  .fair.under { color: var(--under); font-weight:700; }
  .fair.over { color: var(--over); font-weight:700; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .hint { color: var(--muted); font-size:12px; }
  .danger { color: var(--over); }
  .success { color: var(--ok); }
  .accent { color: var(--accent); }
  .divider { height:1px; background:var(--line); margin:8px 0; }
  .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-weight:700; border:1px solid var(--line); padding:2px 6px; border-radius:6px; background:#0c1730; }
  .sticky-footer { position: sticky; bottom: 0; background: var(--panel); padding: 8px; border-top:1px solid var(--line); border-bottom-left-radius:12px; border-bottom-right-radius:12px; }
  .hidden { display:none !important; }
</style>
</head>
<body>
<header>
  <h1>Sideline Timekeeper</h1>
  <div class="grow"></div>
  <div class="toolbar">
    <button class="btn" id="btnSetup">Setup</button>
    <button class="btn" id="btnPlayers">Players</button>
    <button class="btn" id="btnLineup">Lineup</button>
    <button class="btn" id="btnGame">Game</button>
    <button class="btn" id="btnReports">Reports</button>
  </div>
</header>

<div class="wrap">

  <!-- Setup -->
  <section class="panel" id="viewSetup">
    <div class="section-title">1) Roster</div>
    <div class="grid cols-2">
      <div>
        <label class="hint">Enter one per line: <b>Name[,Number][,Preferred (e.g. ST,MF)]</b></label>
        <textarea id="rosterInput" placeholder="Alice,10,ST&#10;Ben,7,MF,DF&#10;Casey,22,DF&#10;..."></textarea>
        <div class="row">
          <button class="btn" id="btnExample">Use Example 17-Player Roster</button>
          <button class="btn primary" id="btnLoadRoster">Apply Roster</button>
        </div>
      </div>
      <div>
        <div class="section-title">Save / Load Game</div>
        <div class="row">
          <button class="btn" id="btnSave">Save Game (JSON)</button>
          <input type="file" id="fileLoad" accept=".json" class="hidden" />
          <button class="btn" id="btnLoad">Load Game (JSON)</button>
          <button class="btn ghost" id="btnClear">Clear All</button>
        </div>
        <div class="divider"></div>
        <div class="section-title">Scheduled Start & Halftime</div>
        <div class="row">
          <label>Schedule (today, 24h):</label>
          <input id="scheduledHHMM" placeholder="14:30" style="max-width:160px" />
          <button class="btn" id="btnSetSchedule">Set</button>
          <span class="hint" id="scheduledLabel"></span>
        </div>
        <div class="row" style="margin-top:8px">
          <button class="btn" id="btnStart">Start / Resume</button>
          <button class="btn" id="btnPause">Pause</button>
          <button class="btn" id="btnHalftime">Start Halftime (10.5m)</button>
          <button class="btn" id="btnEndHalftime">Force End Halftime</button>
        </div>
        <div class="divider"></div>
        <div class="section-title">Timer Configuration</div>
        <div class="row">
          <label>Regulation Minutes:</label>
          <input id="formatMinutes" type="number" min="10" max="120" step="5" style="max-width:120px" />
          <label>Periods:</label>
          <select id="formatPeriods" style="max-width:140px">
            <option value="1">1 Full Time</option>
            <option value="2" selected>2 Halves</option>
            <option value="3">3 Thirds</option>
            <option value="4">4 Quarters</option>
          </select>
          <button class="btn" id="btnApplyFormat">Apply Format</button>
        </div>
        <div class="row" style="margin-top:8px">
          <label>Manual Time:</label>
          <select id="adjustKind" style="max-width:180px">
            <option value="adjustment">Adjustment (+/-)</option>
            <option value="stoppage">Stoppage / Injury</option>
          </select>
          <select id="adjustPeriod" style="max-width:160px"></select>
          <input id="adjustSeconds" placeholder="Seconds" style="max-width:120px" />
          <label class="hint"><input type="checkbox" id="adjustAll" style="margin-right:4px" />All periods</label>
          <button class="btn" id="btnApplyManual">Apply</button>
        </div>
        <p class="hint">Tip: Save at kickoff, halftime, and full time. State also persists in your browser (localStorage).</p>
      </div>
    </div>
  </section>

  <!-- Players -->
  <section class="panel hidden" id="viewPlayers">
    <div class="section-title">Player Management</div>
    
    <!-- Player Actions Toolbar -->
    <div class="toolbar">
      <button class="btn primary" id="btnAddPlayer">Add Player</button>
      <button class="btn" id="btnImportPlayers">Import Players</button>
      <button class="btn" id="btnExportPlayers">Export Players</button>
      <button class="btn" id="btnUpdateStats">Update Statistics</button>
      <button class="btn" id="btnMarkAttendance">Mark Attendance</button>
    </div>
    
    <div class="grid cols-2" style="margin-top: 12px;">
      <!-- Player List -->
      <div>
        <div class="section-title">Team Roster</div>
        <table id="playersTable">
          <thead>
            <tr>
              <th>Name</th>
              <th>#</th>
              <th>Age</th>
              <th>Positions</th>
              <th>Games</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="playersTableBody">
            <!-- Players will be populated here -->
          </tbody>
        </table>
      </div>
      
      <!-- Player Details Panel -->
      <div>
        <div class="section-title">Player Details</div>
        <div id="playerDetailsPanel">
          <p class="hint">Select a player from the list to view details</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Lineup -->
  <section class="panel hidden" id="viewLineup">
    <div class="section-title">2) Pick Starting Lineup (1 GK, 3 DF, 2 MF, 3 ST)</div>
    <div class="grid cols-3">
      <div>
        <div class="section-title">Required Slots</div>
        <ul id="slotList" style="list-style:none;padding:0;margin:0"></ul>
      </div>
      <div>
        <div class="section-title">Roster</div>
        <table id="rosterTable">
          <thead><tr><th>Name</th><th>#</th><th>Preferred</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <div class="section-title">Assignments</div>
        <table id="assignTable">
          <thead><tr><th>Slot</th><th>Player</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
    <div class="sticky-footer row" style="justify-content:space-between">
      <span class="hint">Tap a slot → tap a player to assign. Duplicate prevention included.</span>
      <div class="row">
        <button class="btn ghost" id="btnClearAssign">Clear All</button>
        <button class="btn primary" id="btnStartGame">Start Game</button>
      </div>
    </div>
  </section>

  <!-- Game -->
  <section class="panel hidden" id="viewGame">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <div class="row" style="gap:12px">
        <div class="pill" id="clockLabel">00:00 / 60:00</div>
        <div class="pill" id="statusLabel">PAUSED</div>
        <div class="pill" id="periodPill">1st Half</div>
        <div class="pill" id="metaPill">Stoppage 00:00 • Adjust +00:00</div>
        <div class="pill" id="halfLabel" style="display:none">BREAK</div>
        <div class="pill" id="schedLabel" style="display:none">Starts in 00:00</div>
      </div>
      <div class="row">
        <button class="btn" id="gStart">Start/Resume</button>
        <button class="btn" id="gPause">Pause</button>
        <button class="btn" id="gHalf">Halftime (10.5m)</button>
        <button class="btn" id="gSave">Save</button>
      </div>
      <div class="row" style="margin-top:8px; padding-top:8px; border-top:1px solid var(--line);">
        <span class="section-title" style="margin-bottom:0;">Quick Actions:</span>
        <button class="btn ghost" id="gStoppage30" onclick="apiAddStoppageTime(30)">+30s Stop</button>
        <button class="btn ghost" id="gStoppage60" onclick="apiAddStoppageTime(60)">+1m Stop</button>
        <button class="btn ghost" id="gAdjustMin" onclick="apiAddTimeAdjustment(-60)">-1m Adj</button>
        <button class="btn ghost" id="gAdjustPlus" onclick="apiAddTimeAdjustment(60)">+1m Adj</button>
      </div>
    </div>

    <div class="panel" style="margin-top:12px">
      <div class="section-title">Period Summary</div>
      <table id="periodTable">
        <thead>
          <tr><th>Period</th><th>Reg</th><th>Elapsed</th><th>Adj</th><th>Stop</th><th>Remain</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="grid cols-2" style="margin-top:12px">
      <div class="panel">
        <div class="section-title">On Field</div>
        <table id="onFieldTable">
          <thead>
            <tr><th>Pos</th><th>Name</th><th>#</th><th>Stint</th><th>Total</th><th>Pref</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="panel">
        <div class="section-title">Roster / Choose Replacement</div>
        <table id="rosterGameTable">
          <thead>
            <tr><th>Name</th><th>#</th><th>Status</th><th>Pos</th><th>Stint</th><th>Total</th><th>Pref</th></tr>
          </thead>
          <tbody></tbody>
        </table>
        <div class="divider"></div>
        <div class="row" style="justify-content:space-between">
          <div class="hint">Select OUT from On Field, then IN from Roster. Queue multiple, then commit.</div>
          <div class="row">
            <button class="btn" id="btnQueue">Queue Selected</button>
            <button class="btn" id="btnClearQueue">Clear Queue</button>
            <button class="btn primary" id="btnCommit">Commit Subs</button>
          </div>
        </div>
        <ul id="queueList" style="list-style:none;padding:0;margin-top:8px"></ul>
      </div>
    </div>
  </section>

  <!-- Reports -->
  <section class="panel hidden" id="viewReports">
    <div class="section-title">4) Playing Time Analytics</div>
    <div class="grid cols-2">
      <div class="panel" style="min-height:120px">
        <div class="section-title">Summary</div>
        <p class="accent" id="reportSummary">Add players to view analytics.</p>
        <p class="hint" id="reportDetail"></p>
        <p class="hint" id="reportDistribution"></p>
      </div>
      <div class="panel" style="min-height:120px">
        <div class="section-title">Targets</div>
        <p class="hint" id="reportTargets"></p>
        <p class="hint" id="reportElapsed"></p>
      </div>
    </div>
    <div class="divider"></div>
    <table id="reportTable">
      <thead>
        <tr>
          <th>Name</th>
          <th>#</th>
          <th>Preferred</th>
          <th>Status</th>
          <th>Played</th>
          <th>Target</th>
          <th>Delta</th>
          <th>Share</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <p class="hint" id="reportNote">Delta compares playing time against an equal share of regulation, stoppage, and adjustments.</p>
  </section>

</div>

<script>
/** -------------------------
 *  API Communication Layer
 *  ------------------------- */
const API_BASE = '/api';

// API communication functions for enhanced features
async function apiCall(endpoint, method = 'GET', data = null) {
  try {
    const options = {
      method,
      headers: {'Content-Type': 'application/json'},
    };
    if (data) options.body = JSON.stringify(data);
    
    const response = await fetch(`${API_BASE}${endpoint}`, options);
    const result = await response.json();
    
    if (!result.success) {
      console.error('API Error:', result.error);
      showNotification(result.error || 'API request failed', 'error');
    }
    
    return result;
  } catch (error) {
    console.error('Network error:', error);
    showNotification('Network error', 'error');
    return {success: false, error: error.message};
  }
}

// Enhanced timer control functions using API
async function apiStartGame() {
  const result = await apiCall('/timer/start', 'POST');
  if (result.success) {
    showNotification('Game started', 'success');
    refreshFromAPI();
  }
}

async function apiPauseGame() {
  const result = await apiCall('/timer/pause', 'POST');
  if (result.success) {
    showNotification('Game paused', 'success');
    refreshFromAPI();
  }
}

async function apiStartHalftime() {
  const result = await apiCall('/timer/halftime', 'POST');
  if (result.success) {
    showNotification('Halftime started', 'success');
    refreshFromAPI();
  }
}

async function apiAddStoppageTime(seconds) {
  const result = await apiCall('/timer/stoppage', 'POST', {seconds});
  if (result.success) {
    showNotification(`Added ${seconds}s stoppage time`, 'success');
    refreshFromAPI();
  }
}

async function apiAddTimeAdjustment(seconds, periodIndex = null, applyToAll = false) {
  const result = await apiCall('/timer/adjustment', 'POST', {
    seconds, 
    period_index: periodIndex, 
    apply_to_all: applyToAll
  });
  if (result.success) {
    showNotification(`Added ${seconds}s time adjustment`, 'success');
    refreshFromAPI();
  }
}

async function apiConfigureTimer(minutes, periods) {
  const result = await apiCall('/timer/configure', 'POST', {minutes, periods});
  if (result.success) {
    showNotification('Timer configured', 'success');
    refreshFromAPI();
  }
}

async function apiMakeSubstitution(outName, inName) {
  const result = await apiCall('/substitution', 'POST', {out_name: outName, in_name: inName});
  if (result.success) {
    showNotification(`Substituted ${outName} for ${inName}`, 'success');
    refreshFromAPI();
  }
}

async function refreshFromAPI() {
  const result = await apiCall('/state');
  if (result.success) {
    // Update local state with server data
    updateLocalStateFromAPI(result);
    renderGame();
  }
}

function updateLocalStateFromAPI(apiData) {
  // Update local state with data from API
  const gameState = apiData.game_state;
  const players = apiData.players;
  
  // Update timer state
  state.paused = gameState.paused;
  state.gameStartTs = gameState.game_started ? Date.now() / 1000 - gameState.elapsed_seconds : null;
  state.periodCount = gameState.period_count;
  
  // Update players
  state.players = players.map(p => ({
    name: p.name,
    number: p.number,
    preferred: p.preferred_positions,
    totalSec: p.total_seconds,
    onField: p.on_field,
    position: p.position,
    stintStart: p.on_field && !gameState.paused ? Date.now() / 1000 : null
  }));
}

function showNotification(message, type = 'info') {
  // Simple notification system
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.textContent = message;
  notification.style.cssText = `
    position: fixed; top: 20px; right: 20px; z-index: 1000;
    padding: 12px 20px; border-radius: 8px; color: white;
    background: ${type === 'success' ? '#24c88b' : type === 'error' ? '#ff6b6b' : '#4ea1ff'};
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
  `;
  
  document.body.appendChild(notification);
  setTimeout(() => {
    notification.style.opacity = '0';
    notification.style.transform = 'translateY(-20px)';
    setTimeout(() => document.body.removeChild(notification), 300);
  }, 3000);
}

/** -------------------------
 *  Data Model & Utilities
 *  ------------------------- */
const GAME_LENGTH_MIN = 60;
const HALFTIME_MIN = 10.5;
const PERIOD_LABELS = {1: "Full Time", 2: "Half", 3: "Third", 4: "Quarter"};
const REQUIRED_SLOTS = ["GK","DF","DF","DF","MF","MF","ST","ST","ST"];
const POS_FULL = {GK:"Goalkeeper", DF:"Defender", MF:"Midfielder", ST:"Striker"};
const FAIRNESS_THRESHOLD = 120; // seconds

let state = {
  players: [], // {name, number, preferred, totalSec, onField, position, stintStart}
  gameStartTs: null,
  paused: true,
  breakActive: false,
  halftimeEndTs: null,
  scheduledStartTs: null,
  elapsedAdjustment: 0, // legacy aggregate
  gameLengthSec: GAME_LENGTH_MIN * 60,
  periodCount: 2,
  periodElapsed: [],
  periodAdjust: [],
  periodStoppage: [],
  currentPeriodIndex: 0,
  periodStartTs: null
};

function ordinal(n) {
  const rem100 = n % 100;
  if (rem100 >= 11 && rem100 <= 13) return `${n}th`;
  const rem10 = n % 10;
  const suffix = rem10 === 1 ? "st" : rem10 === 2 ? "nd" : rem10 === 3 ? "rd" : "th";
  return `${n}${suffix}`;
}

function describePeriodLabel(number, total) {
  const base = PERIOD_LABELS[total] || "Period";
  if (total <= 1) return base;
  return `${ordinal(number)} ${base}`;
}

function ensurePeriodArrays() {
  const count = Math.max(1, state.periodCount | 0);
  state.periodCount = count;
  const expand = (arr) => {
    if (!Array.isArray(arr)) arr = [];
    if (arr.length < count) {
      return arr.concat(Array(count - arr.length).fill(0));
    }
    if (arr.length > count) {
      return arr.slice(0, count);
    }
    return arr;
  };
  state.periodElapsed = expand(state.periodElapsed);
  state.periodAdjust = expand(state.periodAdjust);
  state.periodStoppage = expand(state.periodStoppage);
  if (state.currentPeriodIndex >= count) {
    state.currentPeriodIndex = count - 1;
  }
}

function normalizeState() {
  state.gameLengthSec = Number(state.gameLengthSec || GAME_LENGTH_MIN * 60);
  state.periodCount = Number(state.periodCount || 2);
  state.elapsedAdjustment = Number(state.elapsedAdjustment || 0);
  if (typeof state.currentPeriodIndex !== "number") state.currentPeriodIndex = 0;
  if (typeof state.periodStartTs !== "number") state.periodStartTs = null;
  state.breakActive = Boolean(state.breakActive);
  ensurePeriodArrays();
}

function totalAdjustmentSeconds() {
  ensurePeriodArrays();
  return state.periodAdjust.slice(0, state.periodCount).reduce((sum, v) => sum + (v | 0), 0);
}

function recalcAggregateAdjustment() {
  state.elapsedAdjustment = totalAdjustmentSeconds();
}

function totalStoppageSeconds() {
  ensurePeriodArrays();
  return state.periodStoppage.slice(0, state.periodCount).reduce((sum, v) => sum + (v | 0), 0);
}

function targetSecondsTotal() {
  return Math.max(0, state.gameLengthSec + totalStoppageSeconds() + totalAdjustmentSeconds());
}

function targetSecondsPerPlayer() {
  const rosterSize = Math.max(1, state.players.length);
  return targetSecondsTotal() / rosterSize;
}

function baseElapsedSeconds(includeRunning = true) {
  ensurePeriodArrays();
  let total = state.periodElapsed.slice(0, state.periodCount).reduce((sum, v) => sum + (v | 0), 0);
  if (includeRunning && state.periodStartTs && !state.paused && !state.breakActive) {
    total += Math.max(0, nowSec() - state.periodStartTs);
  }
  if (total === 0 && state.gameStartTs) {
    total = Math.max(0, nowSec() - state.gameStartTs);
  }
  return total;
}

function gameElapsedSeconds() {
  return baseElapsedSeconds() + totalAdjustmentSeconds() + totalStoppageSeconds();
}

function periodTargetSeconds(index) {
  ensurePeriodArrays();
  const count = state.periodCount;
  const base = Math.floor(state.gameLengthSec / count);
  const remainder = state.gameLengthSec % count;
  const reg = base + (index < remainder ? 1 : 0);
  return reg + (state.periodAdjust[index] | 0) + (state.periodStoppage[index] | 0);
}

function periodRegulationSeconds(index) {
  const count = state.periodCount;
  const base = Math.floor(state.gameLengthSec / count);
  const remainder = state.gameLengthSec % count;
  return base + (index < remainder ? 1 : 0);
}

function periodRemainingSeconds(index) {
  const target = periodTargetSeconds(index);
  const elapsed = state.periodElapsed[index] + (index === state.currentPeriodIndex && state.periodStartTs && !state.paused && !state.breakActive ? Math.max(0, nowSec() - state.periodStartTs) : 0);
  return Math.max(0, target - elapsed);
}

normalizeState();

let ui = {
  // nav
  btnSetup: document.getElementById("btnSetup"),
  btnLineup: document.getElementById("btnLineup"),
  btnGame: document.getElementById("btnGame"),
  btnReports: document.getElementById("btnReports"),
  btnPlayers: document.getElementById("btnPlayers"),
  viewSetup: document.getElementById("viewSetup"),
  viewLineup: document.getElementById("viewLineup"),
  viewGame: document.getElementById("viewGame"),
  viewReports: document.getElementById("viewReports"),
  viewPlayers: document.getElementById("viewPlayers"),

  // setup
  rosterInput: document.getElementById("rosterInput"),
  btnExample: document.getElementById("btnExample"),
  btnLoadRoster: document.getElementById("btnLoadRoster"),
  btnSave: document.getElementById("btnSave"),
  btnLoad: document.getElementById("btnLoad"),
  btnClear: document.getElementById("btnClear"),
  fileLoad: document.getElementById("fileLoad"),
  scheduledHHMM: document.getElementById("scheduledHHMM"),
  btnSetSchedule: document.getElementById("btnSetSchedule"),
  scheduledLabel: document.getElementById("scheduledLabel"),
  btnStart: document.getElementById("btnStart"),
  btnPause: document.getElementById("btnPause"),
  btnHalftime: document.getElementById("btnHalftime"),
  btnEndHalftime: document.getElementById("btnEndHalftime"),
  formatMinutes: document.getElementById("formatMinutes"),
  formatPeriods: document.getElementById("formatPeriods"),
  btnApplyFormat: document.getElementById("btnApplyFormat"),
  adjustKind: document.getElementById("adjustKind"),
  adjustPeriod: document.getElementById("adjustPeriod"),
  adjustSeconds: document.getElementById("adjustSeconds"),
  adjustAll: document.getElementById("adjustAll"),
  btnApplyManual: document.getElementById("btnApplyManual"),

  // lineup
  slotList: document.getElementById("slotList"),
  rosterTable: document.querySelector("#rosterTable tbody"),
  assignTable: document.querySelector("#assignTable tbody"),
  btnClearAssign: document.getElementById("btnClearAssign"),
  btnStartGame: document.getElementById("btnStartGame"),

  // game
  clockLabel: document.getElementById("clockLabel"),
  statusLabel: document.getElementById("statusLabel"),
  periodPill: document.getElementById("periodPill"),
  metaPill: document.getElementById("metaPill"),
  halfLabel: document.getElementById("halfLabel"),
  schedLabel: document.getElementById("schedLabel"),
  gStart: document.getElementById("gStart"),
  gPause: document.getElementById("gPause"),
  gHalf: document.getElementById("gHalf"),
  gSave: document.getElementById("gSave"),
  periodTable: document.querySelector("#periodTable tbody"),
  onFieldTable: document.querySelector("#onFieldTable tbody"),
  rosterGameTable: document.querySelector("#rosterGameTable tbody"),
  btnQueue: document.getElementById("btnQueue"),
  btnClearQueue: document.getElementById("btnClearQueue"),
  btnCommit: document.getElementById("btnCommit"),
  queueList: document.getElementById("queueList"),

  // reports
  reportSummary: document.getElementById("reportSummary"),
  reportDetail: document.getElementById("reportDetail"),
  reportDistribution: document.getElementById("reportDistribution"),
  reportTargets: document.getElementById("reportTargets"),
  reportElapsed: document.getElementById("reportElapsed"),
  reportTable: document.querySelector("#reportTable tbody"),
  reportNote: document.getElementById("reportNote"),

  // players
  playersTable: document.querySelector("#playersTable tbody"),
  playerDetails: document.getElementById("playerDetails"),
  btnAddPlayer: document.getElementById("btnAddPlayer"),
  btnEditPlayer: document.getElementById("btnEditPlayer"),
  btnDeletePlayer: document.getElementById("btnDeletePlayer"),
  btnImportPlayers: document.getElementById("btnImportPlayers"),
  btnExportPlayers: document.getElementById("btnExportPlayers"),
  btnPlayerStats: document.getElementById("btnPlayerStats"),
  btnAttendance: document.getElementById("btnAttendance"),
};

let selectedSlotIndex = null;  // for lineup
let selectedOutName = null;    // in-game OUT selection
let selectedInName = null;     // in-game IN selection
let subQueue = [];             // [{out,in}]
let tickHandle = null;

function nowSec() { return Math.floor(Date.now()/1000); }
function fmtMMSS(sec) { sec = Math.max(0, sec|0); const m = Math.floor(sec/60), s = sec%60; return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`; }
function fmtSignedMMSS(sec) { const sign = sec >= 0 ? "+" : "-"; return sign + fmtMMSS(Math.abs(sec)); }
function saveLocal() {
  recalcAggregateAdjustment();
  localStorage.setItem("sideline_state", JSON.stringify(state));
}
function loadLocal() {
  const s = localStorage.getItem("sideline_state");
  if (s) {
    try {
      state = JSON.parse(s);
    } catch (err) {
      console.warn("Failed to parse saved state", err);
    }
  }
  normalizeState();
  recalcAggregateAdjustment();
}
function resetAll() {
  state = {
    players: [],
    gameStartTs: null,
    paused: true,
    breakActive: false,
    halftimeEndTs: null,
    scheduledStartTs: null,
    elapsedAdjustment: 0,
    gameLengthSec: GAME_LENGTH_MIN * 60,
    periodCount: 2,
    periodElapsed: [],
    periodAdjust: [],
    periodStoppage: [],
    currentPeriodIndex: 0,
    periodStartTs: null
  };
  normalizeState();
  subQueue = []; selectedOutName = null; selectedInName = null; selectedSlotIndex = null;
  saveLocal(); renderAll();
}

function fairnessClass(totalSec, targetSec = targetSecondsPerPlayer()) {
  const delta = totalSec - targetSec;
  if (delta <= -FAIRNESS_THRESHOLD) return "under";
  if (delta >= FAIRNESS_THRESHOLD) return "over";
  return "ok";
}

function currentStint(p) {
  if (p.onField && p.stintStart) return nowSec() - p.stintStart;
  return 0;
}

function totalLive(p) {
  return (p.totalSec|0) + currentStint(p);
}

function median(values) {
  if (!values.length) return 0;
  const sorted = values.slice().sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  if (sorted.length % 2 === 0) {
    return (sorted[mid - 1] + sorted[mid]) / 2;
  }
  return sorted[mid];
}

/** -------------------------
 *  Navigation & Views
 *  ------------------------- */
function show(view) {
  const views = {
    setup: ui.viewSetup,
    players: ui.viewPlayers,
    lineup: ui.viewLineup,
    game: ui.viewGame,
    reports: ui.viewReports,
  };
  Object.entries(views).forEach(([key, el]) => {
    if (!el) return;
    el.classList.toggle("hidden", view !== key);
  });
  const buttons = {
    setup: ui.btnSetup,
    players: ui.btnPlayers,
    lineup: ui.btnLineup,
    game: ui.btnGame,
    reports: ui.btnReports,
  };
  Object.entries(buttons).forEach(([key, btn]) => {
    if (!btn) return;
    btn.classList.toggle("primary", view === key);
  });
}

ui.btnSetup.onclick = () => { show("setup"); };
ui.btnPlayers.onclick = () => { show("players"); renderPlayers(); };
ui.btnLineup.onclick = () => { show("lineup"); renderLineup(); };
ui.btnGame.onclick = () => { show("game"); renderGame(); };
ui.btnReports.onclick = () => { show("reports"); renderReports(); };

// Player management button handlers
if (ui.btnAddPlayer) ui.btnAddPlayer.onclick = addPlayer;
if (ui.btnEditPlayer) ui.btnEditPlayer.onclick = editPlayer;
if (ui.btnDeletePlayer) ui.btnDeletePlayer.onclick = deletePlayer;
if (ui.btnImportPlayers) ui.btnImportPlayers.onclick = importPlayers;
if (ui.btnExportPlayers) ui.btnExportPlayers.onclick = exportPlayers;
if (ui.btnPlayerStats) ui.btnPlayerStats.onclick = showPlayerStats;
if (ui.btnAttendance) ui.btnAttendance.onclick = showAttendance;

// Initially disable buttons that require selection
if (ui.btnEditPlayer) ui.btnEditPlayer.disabled = true;
if (ui.btnDeletePlayer) ui.btnDeletePlayer.disabled = true;
if (ui.btnPlayerStats) ui.btnPlayerStats.disabled = true;
if (ui.btnAttendance) ui.btnAttendance.disabled = true;

/** -------------------------
 *  Setup
 *  ------------------------- */
ui.btnExample.onclick = () => {
  const sample = [];
  for (let i=1;i<=17;i++){
    const pref = (i<=4)?"ST":(i<=8)?"MF":(i<=14)?"DF":"GK";
    sample.push(`Player ${i},${String(i).padStart(2,"0")},${pref}`);
  }
  ui.rosterInput.value = sample.join("\n");
};

ui.btnLoadRoster.onclick = () => {
  const lines = ui.rosterInput.value.split("\n").map(s=>s.trim()).filter(Boolean);
  const players = [];
  const seen = new Set();
  for (const ln of lines) {
    const parts = ln.split(",").map(s=>s.trim()).filter(s=>s.length);
    const name = parts[0]; if (!name || seen.has(name)) continue;
    seen.add(name);
    const number = parts[1] || "";
    const preferred = parts[2] || "";
    players.push({name, number, preferred, totalSec: 0, onField:false, position:null, stintStart:null});
  }
  if (players.length < 9) { alert("Need at least 9 players."); return; }
  state.players = players;
  saveLocal();
  alert("Roster loaded.");
};

ui.btnSave.onclick = () => {
  // snapshot live totals for save
  const snap = JSON.parse(JSON.stringify(state));
  const n = nowSec();
  snap.players.forEach(p=>{
    if (p.onField && p.stintStart) {
      p.totalSec += (n - p.stintStart);
      // keep stintStart so live resume matches reality
    }
  });
  const blob = new Blob([JSON.stringify(snap,null,2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `sideline_${new Date().toISOString().replace(/[:.]/g,"-")}.json`;
  a.click();
};

ui.btnLoad.onclick = () => ui.fileLoad.click();
ui.fileLoad.onchange = async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const txt = await file.text();
  try {
    const obj = JSON.parse(txt);
    // basic shape validation
    if (!Array.isArray(obj.players)) throw new Error("Invalid file");
    state = obj;
    saveLocal();
    renderAll();
    alert("Game loaded.");
  } catch (err) {
    alert("Failed to load: "+err.message);
  } finally {
    e.target.value = "";
  }
};

ui.btnClear.onclick = () => {
  if (confirm("Clear roster and game state?")) resetAll();
};

ui.btnSetSchedule.onclick = () => {
  const t = ui.scheduledHHMM.value.trim();
  if (!t || !/^\d{1,2}:\d{2}$/.test(t)) { alert("Use HH:MM (24-hour)"); return; }
  const [hh,mm] = t.split(":").map(Number);
  const d = new Date();
  d.setHours(hh, mm, 0, 0);
  state.scheduledStartTs = Math.floor(d.getTime()/1000);
  saveLocal();
  renderSetup();
};

ui.btnStart.onclick = startGame;
ui.btnPause.onclick = pauseGame;
ui.btnHalftime.onclick = startHalftime;
ui.btnEndHalftime.onclick = endHalftime;
ui.btnApplyFormat.onclick = () => {
  const minutes = parseInt(ui.formatMinutes.value, 10);
  const periods = parseInt(ui.formatPeriods.value, 10);
  if (Number.isNaN(minutes) || Number.isNaN(periods)) { alert("Enter minutes and period count."); return; }
  if (minutes < 10 || minutes > 120) { alert("Minutes must be between 10 and 120."); return; }
  if (periods < 1 || periods > 4) { alert("Periods must be between 1 and 4."); return; }
  if (minutes * 60 < periods * 60) { alert("Provide at least one minute per period."); return; }
  if (state.gameStartTs) { alert("Stop/reset the game before changing the timer format."); return; }
  state.gameLengthSec = minutes * 60;
  state.periodCount = periods;
  ensurePeriodArrays();
  state.periodElapsed = Array(periods).fill(0);
  state.periodAdjust = Array(periods).fill(0);
  state.periodStoppage = Array(periods).fill(0);
  state.currentPeriodIndex = 0;
  state.periodStartTs = null;
  recalcAggregateAdjustment();
  saveLocal();
  renderAll();
};

ui.adjustKind.onchange = () => {
  const isStoppage = ui.adjustKind.value === "stoppage";
  ui.adjustAll.disabled = isStoppage;
  if (isStoppage) ui.adjustAll.checked = false;
};

ui.btnApplyManual.onclick = () => {
  ensurePeriodArrays();
  const kind = ui.adjustKind.value;
  const periodIndex = parseInt(ui.adjustPeriod.value, 10);
  const seconds = parseInt(ui.adjustSeconds.value, 10);
  if (Number.isNaN(periodIndex)) { alert("Select a period."); return; }
  if (Number.isNaN(seconds)) { alert("Enter seconds (integer)."); return; }
  if (kind === "adjustment") {
    if (seconds === 0) { alert("Enter a non-zero adjustment."); return; }
    if (ui.adjustAll.checked) {
      for (let i = 0; i < state.periodCount; i++) {
        state.periodAdjust[i] += seconds;
      }
    } else {
      state.periodAdjust[periodIndex] += seconds;
    }
    recalcAggregateAdjustment();
  } else {
    if (seconds <= 0) { alert("Stoppage time must be positive seconds."); return; }
    state.periodStoppage[periodIndex] = Math.max(0, state.periodStoppage[periodIndex] + seconds);
  }
  ui.adjustSeconds.value = "";
  saveLocal();
  renderAll();
};

/** -------------------------
 *  Lineup
 *  ------------------------- */
function renderLineup() {
  // slots
  ui.slotList.innerHTML = "";
  REQUIRED_SLOTS.forEach((pos, idx)=>{
    const li = document.createElement("li");
    li.style.padding="6px 8px";
    li.style.border="1px solid var(--line)";
    li.style.borderRadius="8px";
    li.style.marginBottom="6px";
    li.style.cursor="pointer";
    li.dataset.index = idx;
    li.innerHTML = `<b>${idx+1}. ${pos}</b> – ${POS_FULL[pos]}`;
    li.onclick = () => { selectedSlotIndex = idx; highlightSlots(); };
    ui.slotList.appendChild(li);
  });
  highlightSlots();

  // roster table
  ui.rosterTable.innerHTML = "";
  state.players.slice().sort((a,b)=> (a.number||"").localeCompare(b.number||"") || a.name.localeCompare(b.name))
    .forEach(p=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${p.name}</td><td>${p.number||""}</td><td>${(p.preferred||"").toUpperCase()}</td>`;
      tr.style.cursor="pointer";
      tr.onclick = ()=>assignSelectedSlot(p.name);
      ui.rosterTable.appendChild(tr);
    });

  // assignments table mirrors an internal map kept via DOM
  ui.assignTable.innerHTML = "";
}

function highlightSlots() {
  Array.from(ui.slotList.children).forEach((li,i)=>{
    li.style.background = (i===selectedSlotIndex) ? "#0c1732" : "transparent";
  });
}

function assignSelectedSlot(playerName) {
  if (selectedSlotIndex===null) { alert("Select a slot on the left first."); return; }
  // prevent duplicate player
  const existing = Array.from(ui.assignTable.querySelectorAll("tr td:nth-child(2)")).map(td=>td.textContent);
  if (existing.includes(playerName)) { alert("Player already assigned."); return; }

  // remove previous assignment on this slot
  const slotLabel = `${selectedSlotIndex+1}. ${REQUIRED_SLOTS[selectedSlotIndex]}`;
  const rows = Array.from(ui.assignTable.querySelectorAll("tr"));
  for (const r of rows) {
    if (r.children[0].textContent === slotLabel) r.remove();
  }

  const tr = document.createElement("tr");
  tr.innerHTML = `<td>${slotLabel}</td><td>${playerName}</td>`;
  ui.assignTable.appendChild(tr);
}

ui.btnClearAssign.onclick = () => { ui.assignTable.innerHTML = ""; };

ui.btnStartGame.onclick = () => {
  // Build assignments
  const assigned = {};
  Array.from(ui.assignTable.querySelectorAll("tr")).forEach(r=>{
    const slot = r.children[0].textContent; // "1. GK"
    const pos = slot.split(".")[1].trim().split(" ")[0];
    const name = r.children[1].textContent;
    assigned[pos] = (assigned[pos]||[]).concat([name]);
  });
  // Validate exact formation
  const need = {GK:1, DF:3, MF:2, ST:3};
  const got = {GK:(assigned.GK||[]).length, DF:(assigned.DF||[]).length, MF:(assigned.MF||[]).length, ST:(assigned.ST||[]).length};
  if (JSON.stringify(need)!==JSON.stringify(got)) { alert(`Need exactly ${JSON.stringify(need)}, got ${JSON.stringify(got)}`); return; }

  // Reset and apply
  const n = nowSec();
  state.players.forEach(p=>{ p.onField=false; p.position=null; p.stintStart=null; });
  for (const [pos, names] of Object.entries(assigned)) {
    for (const nm of names) {
      const p = state.players.find(x=>x.name===nm);
      if (p) { p.onField = true; p.position = pos; p.stintStart = n; }
    }
  }
  const firstStart = !state.gameStartTs;
  if (firstStart) state.gameStartTs = n;
  ensurePeriodArrays();
  if (firstStart) {
    state.currentPeriodIndex = 0;
    state.periodElapsed = Array(state.periodCount).fill(0);
  }
  state.periodStartTs = n;
  state.breakActive = false;
  state.paused = false;
  saveLocal();
  show("game");
  renderGame();
  startTick();
};

/** -------------------------
 *  Game
 *  ------------------------- */
function startGame() {
  // Try API first, fall back to local
  apiStartGame().catch(() => {
    // Fallback to original local implementation
    ensurePeriodArrays();
    const n = nowSec();
    const firstStart = !state.gameStartTs;
    if (firstStart) {
      state.gameStartTs = n;
      state.currentPeriodIndex = 0;
      state.periodElapsed = Array(state.periodCount).fill(0);
    }
    if (!state.periodStartTs || state.paused || state.breakActive) {
      state.periodStartTs = n;
    }
    state.breakActive = false;
    state.paused = false;
    state.players.forEach(p=>{
      if (p.onField && !p.stintStart) p.stintStart = n;
    });
    saveLocal();
    renderGame();
    startTick();
  });
}

function pauseGame() {
  // Try API first, fall back to local
  apiPauseGame().catch(() => {
    // Fallback to original local implementation
    if (state.paused) return;
    const n = nowSec();
    ensurePeriodArrays();
    if (state.periodStartTs) {
      state.periodElapsed[state.currentPeriodIndex] += Math.max(0, n - state.periodStartTs);
      state.periodStartTs = null;
    }
    state.players.forEach(p=>{
      if (p.onField && p.stintStart) {
        p.totalSec += (n - p.stintStart);
        p.stintStart = null;
      }
    });
    state.paused = true;
    saveLocal();
    renderGame();
    stopTick();
  });
}

function startHalftime() {
  // Try API first, fall back to local
  apiStartHalftime().catch(() => {
    // Fallback to original local implementation
    pauseGame();
    state.breakActive = true;
    state.halftimeEndTs = nowSec() + Math.floor(HALFTIME_MIN*60);
    saveLocal();
    renderGame();
    startTick(); // to show countdown
  });
}

function endHalftime() {
  ensurePeriodArrays();
  state.breakActive = false;
  state.halftimeEndTs = null;
  if (state.currentPeriodIndex < state.periodCount - 1) {
    state.currentPeriodIndex += 1;
  }
  const n = nowSec();
  state.periodStartTs = n;
  state.paused = false;
  if (!state.gameStartTs) state.gameStartTs = n;
  state.players.forEach(p=>{
    if (p.onField && !p.stintStart) p.stintStart = n;
  });
  saveLocal();
  renderGame();
  startTick();
}

ui.gStart.onclick = startGame;
ui.gPause.onclick = pauseGame;
ui.gHalf.onclick = startHalftime;
ui.gSave.onclick = () => ui.btnSave.click();

function renderGame() {
  ensurePeriodArrays();
  const elapsed = gameElapsedSeconds();
  const target = state.gameLengthSec + totalStoppageSeconds();
  ui.clockLabel.textContent = `${fmtMMSS(elapsed)} / ${fmtMMSS(target)}`;
  ui.statusLabel.textContent = state.paused ? "PAUSED" : "RUNNING";

  const periodLabel = describePeriodLabel(state.currentPeriodIndex + 1, state.periodCount);
  ui.periodPill.textContent = `${periodLabel} (${state.currentPeriodIndex + 1}/${state.periodCount})`;
  ui.metaPill.textContent = `Stoppage ${fmtMMSS(totalStoppageSeconds())} • Adjust ${fmtSignedMMSS(totalAdjustmentSeconds())}`;

  if (state.breakActive) {
    if (state.halftimeEndTs && nowSec() <= state.halftimeEndTs) {
      const remain = Math.max(0, state.halftimeEndTs - nowSec());
      ui.halfLabel.style.display = "";
      ui.halfLabel.textContent = `BREAK ${fmtMMSS(remain)}`;
    } else {
      ui.halfLabel.style.display = "";
      ui.halfLabel.textContent = "BREAK";
    }
  } else {
    ui.halfLabel.style.display = "none";
  }

  if (state.scheduledStartTs && !state.gameStartTs) {
    const delta = state.scheduledStartTs - nowSec();
    if (delta > 0) {
      ui.schedLabel.style.display = "";
      ui.schedLabel.textContent = `Starts in ${fmtMMSS(delta)}`;
    } else {
      ui.schedLabel.style.display = "";
      ui.schedLabel.textContent = `Starting…`;
      startGame();
    }
  } else {
    ui.schedLabel.style.display = "none";
  }

  ui.periodTable.innerHTML = "";
  const now = nowSec();
  for (let i = 0; i < state.periodCount; i++) {
    const running = (i === state.currentPeriodIndex && state.periodStartTs && !state.paused && !state.breakActive)
      ? Math.max(0, now - state.periodStartTs)
      : 0;
    const elapsedReg = (state.periodElapsed[i] || 0) + running;
    const adjust = state.periodAdjust[i] || 0;
    const stoppage = state.periodStoppage[i] || 0;
    const remain = periodRemainingSeconds(i);
    const tr = document.createElement("tr");
    if (i === state.currentPeriodIndex && !state.breakActive) {
      tr.style.fontWeight = "600";
    }
    tr.innerHTML = `
      <td>${describePeriodLabel(i + 1, state.periodCount)}</td>
      <td>${fmtMMSS(periodRegulationSeconds(i))}</td>
      <td>${fmtMMSS(elapsedReg)}</td>
      <td>${fmtSignedMMSS(adjust)}</td>
      <td>${fmtMMSS(stoppage)}</td>
      <td>${fmtMMSS(remain)}</td>
    `;
    ui.periodTable.appendChild(tr);
  }

  // On-field table
  ui.onFieldTable.innerHTML = "";
  const order = {GK:0, DF:1, MF:2, ST:3};
  const on = state.players.filter(p=>p.onField).sort((a,b)=>
     (order[a.position||"Z"] - order[b.position||"Z"]) ||
     (a.number||"").localeCompare(b.number||"") ||
     a.name.localeCompare(b.name));

  on.forEach(p=>{
    const stint = currentStint(p);
    const total = totalLive(p);
    const tr = document.createElement("tr");
    tr.onclick = ()=>{ selectedOutName = p.name; highlightSelections(); };
    tr.innerHTML = `
      <td>${p.position||"-"}</td>
      <td>${p.name}</td>
      <td>${p.number||""}</td>
      <td>${fmtMMSS(stint)}</td>
      <td><span class="fair ${fairnessClass(total)}">${fmtMMSS(total)}</span></td>
      <td>${(p.preferred||"").toUpperCase()}</td>`;
    ui.onFieldTable.appendChild(tr);
  });

  // Roster table
  ui.rosterGameTable.innerHTML = "";
  state.players.slice().sort((a,b)=> (a.onField===b.onField?0:a.onField?-1:1) || (a.number||"").localeCompare(b.number||"") || a.name.localeCompare(b.name))
    .forEach(p=>{
      const stint = currentStint(p);
      const total = totalLive(p);
      const tr = document.createElement("tr");
      tr.onclick = ()=>{ selectedInName = p.name; highlightSelections(); };
      tr.innerHTML = `
        <td>${p.name}</td>
        <td>${p.number||""}</td>
        <td>${p.onField?'<span class="pill status-in">IN</span>':'<span class="pill status-out">OUT</span>'}</td>
        <td>${p.position||"-"}</td>
        <td>${fmtMMSS(stint)}</td>
        <td><span class="fair ${fairnessClass(total)}">${fmtMMSS(total)}</span></td>
        <td>${(p.preferred||"").toUpperCase()}</td>`;
      ui.rosterGameTable.appendChild(tr);
    });

  // queue
  ui.queueList.innerHTML = "";
  subQueue.forEach((q, i)=>{
    const li = document.createElement("li");
    li.className = "row";
    li.style.justifyContent="space-between";
    li.style.padding="6px 0";
    li.innerHTML = `<span>${q.out} &rarr; <b>${q._label||q.in}</b></span>
      <button class="btn" onclick="removeQueue(${i})">Remove</button>`;
    ui.queueList.appendChild(li);
  });

  renderReports();
}

function highlightSelections() {
  // you’ll see selections in queue labels; table row highlighting is optional
}

ui.btnQueue.onclick = () => {
  if (!selectedOutName) { alert("Select someone on the field to sub OUT."); return; }
  if (!selectedInName) { alert("Select a roster player to sub IN / swap."); return; }
  if (selectedOutName === selectedInName) { alert("Pick a different player for replacement."); return; }

  // Label includes target slot (out player's position)
  const outP = state.players.find(p=>p.name===selectedOutName);
  const inP = state.players.find(p=>p.name===selectedInName);
  const label = inP.name + (inP.onField ? ` (swap to ${outP.position})` : "");
  subQueue.push({out: selectedOutName, in: selectedInName, _label: label});
  selectedOutName = null; selectedInName = null;
  renderGame();
};

ui.btnClearQueue.onclick = () => { subQueue = []; renderGame(); };

function removeQueue(i) { subQueue.splice(i,1); renderGame(); }
window.removeQueue = removeQueue; // expose for onclick

ui.btnCommit.onclick = () => {
  if (!subQueue.length) { alert("No subs queued."); return; }
  const n = nowSec();
  subQueue.forEach(q=>{
    const pOut = state.players.find(p=>p.name===q.out);
    const pIn  = state.players.find(p=>p.name===q.in);
    if (!pOut || !pIn || !pOut.onField || !pOut.position) return;

    // end OUT stint
    if (pOut.stintStart) { pOut.totalSec += (n - pOut.stintStart); }
    pOut.onField = false; pOut.position = null; pOut.stintStart = null;

    // if IN is on field → position swap
    if (pIn.onField) {
      pIn.position = pOut.position;
      // optional: place OUT into IN's old spot instead of benching (coach asked for one-way replace)
      // to enable true swap both ways, uncomment below:
      // pOut.onField = true; pOut.position = old; pOut.stintStart = n;
    } else {
      pIn.onField = true; pIn.position = pOut.position; pIn.stintStart = n;
    }
  });
  subQueue = [];
  saveLocal();
  renderGame();
};

function startTick() {
  if (tickHandle) return;
  tickHandle = setInterval(()=>{
    // halftime countdown end
    if (state.halftimeEndTs && nowSec() >= state.halftimeEndTs) {
      state.halftimeEndTs = null;
      state.breakActive = false;
      saveLocal();
      alert("Halftime complete. Press Start/Resume to continue.");
    }
    renderGame();
    renderReports();
  }, 1000);
}
function stopTick(){ if (tickHandle) { clearInterval(tickHandle); tickHandle = null; } }

function renderReports() {
  if (!ui.reportSummary) return;
  ensurePeriodArrays();

  const roster = state.players.slice();
  if (!roster.length) {
    ui.reportSummary.textContent = "Add players to view analytics.";
    ui.reportDetail.textContent = "";
    ui.reportDistribution.textContent = "";
    ui.reportTargets.textContent = "";
    ui.reportElapsed.textContent = "";
    ui.reportTable.innerHTML = "";
    return;
  }

  const elapsed = gameElapsedSeconds();
  const totalTarget = Math.round(targetSecondsTotal());
  const perPlayerTarget = targetSecondsPerPlayer();
  const perPlayerRounded = Math.round(perPlayerTarget);
  const stoppage = totalStoppageSeconds();
  const adjustments = totalAdjustmentSeconds();

  ui.reportSummary.textContent = `Elapsed ${fmtMMSS(elapsed)} / Target ${fmtMMSS(totalTarget)} — ${roster.length} players`;
  ui.reportDetail.textContent = `Regulation ${fmtMMSS(state.gameLengthSec)} • Stoppage ${fmtMMSS(stoppage)} • Adjust ${fmtSignedMMSS(adjustments)}`;
  ui.reportTargets.textContent = `Per player target ${fmtMMSS(perPlayerRounded)}`;
  ui.reportElapsed.textContent = `Remaining ${fmtMMSS(Math.max(0, totalTarget - elapsed))}`;

  const totals = roster.map(p => totalLive(p));
  const average = totals.length ? totals.reduce((sum, value) => sum + value, 0) / totals.length : 0;
  const med = median(totals);
  const minVal = totals.length ? Math.min(...totals) : 0;
  const maxVal = totals.length ? Math.max(...totals) : 0;
  ui.reportDistribution.textContent = `Average ${fmtMMSS(Math.round(average))} • Median ${fmtMMSS(Math.round(med))} • Range ${fmtMMSS(minVal)}–${fmtMMSS(maxVal)}`;

  const fairnessOrder = {under: 0, ok: 1, over: 2};
  const rows = roster.map(p => {
    const total = totalLive(p);
    const delta = Math.round(total - perPlayerTarget);
    const fairness = fairnessClass(total, perPlayerTarget);
    const share = perPlayerTarget > 0 ? (total / perPlayerTarget) * 100 : 0;
    const status = p.onField ? `On Field${p.position ? ` (${p.position})` : ""}` : "Bench";
    return { player: p, total, delta, fairness, share, status };
  });

  rows.sort((a, b) => {
    if (fairnessOrder[a.fairness] !== fairnessOrder[b.fairness]) {
      return fairnessOrder[a.fairness] - fairnessOrder[b.fairness];
    }
    if (a.delta !== b.delta) return a.delta - b.delta;
    return a.player.name.localeCompare(b.player.name);
  });

  ui.reportTable.innerHTML = "";
  rows.forEach(row => {
    const tr = document.createElement("tr");
    const preferred = (row.player.preferred || "").toUpperCase();
    const shareText = `${row.share.toFixed(1)}%`;
    tr.innerHTML = `
      <td>${row.player.name}</td>
      <td>${row.player.number || ""}</td>
      <td>${preferred}</td>
      <td>${row.status}</td>
      <td><span class="fair ${row.fairness}">${fmtMMSS(row.total)}</span></td>
      <td>${fmtMMSS(perPlayerRounded)}</td>
      <td><span class="fair ${row.fairness}">${fmtSignedMMSS(row.delta)}</span></td>
      <td>${shareText}</td>
    `;
    ui.reportTable.appendChild(tr);
  });
}

/** -------------------------
 *  Setup view secondary render
 *  ------------------------- */
function renderSetup() {
  if (state.scheduledStartTs) {
    const d = new Date(state.scheduledStartTs*1000);
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    ui.scheduledLabel.textContent = `Scheduled for ${hh}:${mm}`;
  } else {
    ui.scheduledLabel.textContent = "";
  }
  ui.formatMinutes.value = Math.round(state.gameLengthSec/60);
  ui.formatPeriods.value = String(state.periodCount);
  updatePeriodOptions();
}

function updatePeriodOptions() {
  ensurePeriodArrays();
  ui.adjustPeriod.innerHTML = "";
  for (let i = 0; i < state.periodCount; i++) {
    const option = document.createElement("option");
    option.value = String(i);
    option.textContent = describePeriodLabel(i + 1, state.periodCount);
    ui.adjustPeriod.appendChild(option);
  }
  if (state.periodCount > 0 && !ui.adjustPeriod.value) {
    ui.adjustPeriod.value = "0";
  }
  if (typeof ui.adjustKind.onchange === "function") {
    ui.adjustKind.onchange();
  }
}

/** -------------------------
 *  Players View Functions
 *  ------------------------- */

let selectedPlayer = null;

// Render the players table
function renderPlayers() {
  if (!ui.playersTable) return;
  
  fetch('/api/players')
    .then(response => response.json())
    .then(players => {
      ui.playersTable.innerHTML = '';
      players.forEach(player => {
        const row = ui.playersTable.insertRow();
        row.onclick = () => selectPlayer(player);
        row.innerHTML = `
          <td>${player.name}</td>
          <td>${player.position}</td>
          <td>${player.skill_level}</td>
          <td>${player.contact_info ? player.contact_info.phone || 'N/A' : 'N/A'}</td>
          <td>${player.stats ? player.stats.goals : 0}</td>
          <td>${player.stats ? player.stats.assists : 0}</td>
          <td>${player.attendance ? player.attendance.length : 0}</td>
        `;
      });
    })
    .catch(error => {
      console.error('Error loading players:', error);
      alert('Error loading players: ' + error.message);
    });
}

// Select a player and show details
function selectPlayer(player) {
  selectedPlayer = player;
  if (ui.playerDetails) {
    ui.playerDetails.innerHTML = `
      <h3>${player.name}</h3>
      <p><strong>Position:</strong> ${player.position}</p>
      <p><strong>Skill Level:</strong> ${player.skill_level}</p>
      ${player.contact_info ? `
        <h4>Contact Information</h4>
        <p><strong>Phone:</strong> ${player.contact_info.phone || 'N/A'}</p>
        <p><strong>Email:</strong> ${player.contact_info.email || 'N/A'}</p>
        <p><strong>Emergency Contact:</strong> ${player.contact_info.emergency_contact || 'N/A'}</p>
        <p><strong>Emergency Phone:</strong> ${player.contact_info.emergency_phone || 'N/A'}</p>
      ` : ''}
      ${player.medical_info ? `
        <h4>Medical Information</h4>
        <p><strong>Allergies:</strong> ${player.medical_info.allergies ? player.medical_info.allergies.join(', ') : 'None'}</p>
        <p><strong>Medications:</strong> ${player.medical_info.medications ? player.medical_info.medications.join(', ') : 'None'}</p>
        <p><strong>Medical Notes:</strong> ${player.medical_info.medical_notes || 'None'}</p>
      ` : ''}
      ${player.stats ? `
        <h4>Statistics</h4>
        <p><strong>Goals:</strong> ${player.stats.goals}</p>
        <p><strong>Assists:</strong> ${player.stats.assists}</p>
        <p><strong>Yellow Cards:</strong> ${player.stats.yellow_cards}</p>
        <p><strong>Red Cards:</strong> ${player.stats.red_cards}</p>
        <p><strong>Games Played:</strong> ${player.stats.games_played}</p>
        <p><strong>Total Minutes:</strong> ${player.stats.total_minutes}</p>
      ` : ''}
    `;
  }
  
  // Enable/disable action buttons based on selection
  if (ui.btnEditPlayer) ui.btnEditPlayer.disabled = false;
  if (ui.btnDeletePlayer) ui.btnDeletePlayer.disabled = false;
  if (ui.btnPlayerStats) ui.btnPlayerStats.disabled = false;
  if (ui.btnAttendance) ui.btnAttendance.disabled = false;
}

// Add new player
function addPlayer() {
  const name = prompt('Enter player name:');
  if (!name) return;
  
  const position = prompt('Enter position (forward, midfielder, defender, goalkeeper):', 'midfielder');
  if (!position) return;
  
  const skillLevel = prompt('Enter skill level (1-10):', '5');
  if (!skillLevel) return;
  
  const playerData = {
    name: name,
    position: position,
    skill_level: parseInt(skillLevel)
  };
  
  fetch('/api/players', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(playerData)
  })
    .then(response => response.json())
    .then(() => {
      renderPlayers();
      alert('Player added successfully!');
    })
    .catch(error => {
      console.error('Error adding player:', error);
      alert('Error adding player: ' + error.message);
    });
}

// Edit selected player
function editPlayer() {
  if (!selectedPlayer) {
    alert('Please select a player first.');
    return;
  }
  
  const name = prompt('Edit player name:', selectedPlayer.name);
  if (name === null) return;
  
  const position = prompt('Edit position:', selectedPlayer.position);
  if (position === null) return;
  
  const skillLevel = prompt('Edit skill level (1-10):', selectedPlayer.skill_level.toString());
  if (skillLevel === null) return;
  
  const playerData = {
    name: name,
    position: position,
    skill_level: parseInt(skillLevel)
  };
  
  fetch(`/api/players/${selectedPlayer.name}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(playerData)
  })
    .then(response => response.json())
    .then(() => {
      renderPlayers();
      selectedPlayer = null;
      ui.playerDetails.innerHTML = '';
      alert('Player updated successfully!');
    })
    .catch(error => {
      console.error('Error updating player:', error);
      alert('Error updating player: ' + error.message);
    });
}

// Delete selected player
function deletePlayer() {
  if (!selectedPlayer) {
    alert('Please select a player first.');
    return;
  }
  
  if (!confirm(`Are you sure you want to delete player ${selectedPlayer.name}?`)) {
    return;
  }
  
  fetch(`/api/players/${selectedPlayer.name}`, {
    method: 'DELETE'
  })
    .then(() => {
      renderPlayers();
      selectedPlayer = null;
      ui.playerDetails.innerHTML = '';
      alert('Player deleted successfully!');
    })
    .catch(error => {
      console.error('Error deleting player:', error);
      alert('Error deleting player: ' + error.message);
    });
}

// Import players from CSV
function importPlayers() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.csv';
  input.onchange = function(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const formData = new FormData();
    formData.append('file', file);
    
    fetch('/api/players/import', {
      method: 'POST',
      body: formData
    })
      .then(response => response.json())
      .then(result => {
        renderPlayers();
        alert(`Import completed! Added ${result.added} players, updated ${result.updated} players.`);
      })
      .catch(error => {
        console.error('Error importing players:', error);
        alert('Error importing players: ' + error.message);
      });
  };
  input.click();
}

// Export players to CSV
function exportPlayers() {
  fetch('/api/players/export')
    .then(response => response.blob())
    .then(blob => {
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'players.csv';
      a.click();
      window.URL.revokeObjectURL(url);
    })
    .catch(error => {
      console.error('Error exporting players:', error);
      alert('Error exporting players: ' + error.message);
    });
}

// Show player statistics
function showPlayerStats() {
  if (!selectedPlayer) {
    alert('Please select a player first.');
    return;
  }
  
  fetch(`/api/players/${selectedPlayer.name}/stats`)
    .then(response => response.json())
    .then(stats => {
      const statsWindow = window.open('', '_blank', 'width=600,height=400');
      statsWindow.document.write(`
        <html>
        <head><title>${selectedPlayer.name} - Statistics</title></head>
        <body>
          <h2>${selectedPlayer.name} - Statistics</h2>
          <table border="1" cellpadding="5">
            <tr><td><strong>Goals:</strong></td><td>${stats.goals}</td></tr>
            <tr><td><strong>Assists:</strong></td><td>${stats.assists}</td></tr>
            <tr><td><strong>Yellow Cards:</strong></td><td>${stats.yellow_cards}</td></tr>
            <tr><td><strong>Red Cards:</strong></td><td>${stats.red_cards}</td></tr>
            <tr><td><strong>Games Played:</strong></td><td>${stats.games_played}</td></tr>
            <tr><td><strong>Total Minutes:</strong></td><td>${stats.total_minutes}</td></tr>
            <tr><td><strong>Average Minutes/Game:</strong></td><td>${stats.games_played > 0 ? Math.round(stats.total_minutes / stats.games_played) : 0}</td></tr>
          </table>
          <button onclick="window.close()">Close</button>
        </body>
        </html>
      `);
    })
    .catch(error => {
      console.error('Error loading player stats:', error);
      alert('Error loading player stats: ' + error.message);
    });
}

// Show attendance tracking
function showAttendance() {
  if (!selectedPlayer) {
    alert('Please select a player first.');
    return;
  }
  
  fetch(`/api/players/${selectedPlayer.name}/attendance`)
    .then(response => response.json())
    .then(attendance => {
      const attendanceWindow = window.open('', '_blank', 'width=600,height=400');
      const attendanceRows = attendance.map(record => 
        `<tr>
          <td>${record.date}</td>
          <td>${record.present ? 'Present' : 'Absent'}</td>
          <td>${record.minutes_played || 0}</td>
          <td>${record.notes || ''}</td>
        </tr>`
      ).join('');
      
      attendanceWindow.document.write(`
        <html>
        <head><title>${selectedPlayer.name} - Attendance</title></head>
        <body>
          <h2>${selectedPlayer.name} - Attendance</h2>
          <table border="1" cellpadding="5">
            <thead>
              <tr>
                <th>Date</th>
                <th>Status</th>
                <th>Minutes Played</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              ${attendanceRows}
            </tbody>
          </table>
          <button onclick="window.close()">Close</button>
        </body>
        </html>
      `);
    })
    .catch(error => {
      console.error('Error loading attendance:', error);
      alert('Error loading attendance: ' + error.message);
    });
}

/** -------------------------
 *  Boot
 *  ------------------------- */
function renderAll() {
  renderSetup();
  renderLineup();
  renderGame();
  renderReports();
  renderPlayers();
}
loadLocal();
renderAll();
show("setup");
startTick(); // keep countdown labels alive even when paused
</script>
</body>
</html>
