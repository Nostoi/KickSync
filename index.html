<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sideline Timekeeper</title>
<style>
  :root {
    --bg: #0b1220; --panel: #101a32; --ink: #e6eefc; --muted:#9fb0d1;
    --accent:#4ea1ff; --ok:#24c88b; --under:#ffb020; --over:#ff6b6b;
    --warn:#ffd166; --line:#1f2c4d;
  }
  * { box-sizing: border-box; }
  html, body { margin:0; height:100%; background:var(--bg); color:var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  header { padding: 12px 16px; background: #0a142a; border-bottom:1px solid var(--line); display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  header h1 { font-size: 18px; margin:0; font-weight:700; }
  header .grow { flex:1; }
  .btn {
    appearance:none; border:1px solid var(--line); background:#0e1a36; color:var(--ink);
    padding:8px 12px; border-radius:8px; font-weight:600; cursor:pointer;
  }
  .btn.primary { background:var(--accent); color:#001933; border-color:#2a81e0; }
  .btn.warn { background:var(--warn); color:#1b1400; border-color:#caa94a; }
  .btn.ghost { background:transparent; }
  .btn:disabled { opacity:.5; cursor:not-allowed; }
  .toolbar { display:flex; gap:8px; flex-wrap:wrap; }
  .wrap { padding:12px; display:flex; gap:12px; flex-direction:column; }
  .panel { background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:12px; }
  .grid { display:grid; gap:12px; }
  @media (min-width: 960px) {
    .grid.cols-2 { grid-template-columns: 1fr 1fr; }
    .grid.cols-3 { grid-template-columns: 1fr 1fr 1fr; }
  }
  .section-title { font-size:14px; color:var(--muted); margin-bottom:8px; text-transform:uppercase; letter-spacing:.06em; }
  input, select, textarea {
    width:100%; background:#0b1530; border:1px solid var(--line); color:var(--ink);
    padding:8px; border-radius:8px;
  }
  textarea { min-height: 160px; }
  table { width:100%; border-collapse: collapse; }
  th, td { text-align:left; padding:8px; border-bottom: 1px solid var(--line); font-size:14px; }
  th { color: var(--muted); font-weight:600; }
  tr:hover td { background:#0c1732; }
  .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--line); font-size:12px; color:var(--muted); }
  .status-in { background:#0b2a17; color:#b6f2ce; border-color:#1f5030; }
  .status-out { background:#2a0b0b; color:#f2b6b6; border-color:#502323; }
  .fair.ok { color: var(--ok); font-weight:700; }
  .fair.under { color: var(--under); font-weight:700; }
  .fair.over { color: var(--over); font-weight:700; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .hint { color: var(--muted); font-size:12px; }
  .danger { color: var(--over); }
  .success { color: var(--ok); }
  .accent { color: var(--accent); }
  .divider { height:1px; background:var(--line); margin:8px 0; }
  .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-weight:700; border:1px solid var(--line); padding:2px 6px; border-radius:6px; background:#0c1730; }
  .sticky-footer { position: sticky; bottom: 0; background: var(--panel); padding: 8px; border-top:1px solid var(--line); border-bottom-left-radius:12px; border-bottom-right-radius:12px; }
  .hidden { display:none !important; }
  
  /* Lineup visual cues */
  .slot-filled { background: rgba(36, 200, 139, 0.15) !important; border-color: var(--ok) !important; color: var(--ok) !important; }
  .player-used { background: rgba(255, 107, 107, 0.15) !important; color: var(--muted) !important; opacity: 0.6; cursor: not-allowed !important; }
  .slot-filled::after { content: ' âœ“'; color: var(--ok); font-weight: bold; float: right; }
  .player-used::after { content: ' ASSIGNED'; color: var(--over); font-size: 10px; text-transform: uppercase; float: right; font-weight: bold; }
  
  /* Substitution UI enhancements */
  .selected-out { background: rgba(255, 107, 107, 0.25) !important; border: 2px solid var(--over) !important; }
  .selected-out td { font-weight: bold; }
  .selected-out td:first-child::before { content: 'ðŸ”´ OUT: '; color: var(--over); }
  .selected-in { background: rgba(36, 200, 139, 0.25) !important; border: 2px solid var(--ok) !important; }
  .selected-in td { font-weight: bold; }
  .selected-in td:first-child::before { content: 'ðŸŸ¢ IN: '; color: var(--ok); }
  .queue-item { 
    background: rgba(78, 161, 255, 0.1); 
    border: 1px solid var(--accent); 
    border-radius: 8px; 
    padding: 12px; 
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .queue-item .sub-arrow { 
    font-size: 20px; 
    color: var(--accent); 
    margin: 0 8px;
  }
  .queue-item .player-out { 
    color: var(--over); 
    font-weight: bold;
  }
  .queue-item .player-in { 
    color: var(--ok); 
    font-weight: bold;
  }
  .queue-item .position-badge { 
    background: var(--accent); 
    color: #001933; 
    padding: 2px 8px; 
    border-radius: 4px; 
    font-size: 11px; 
    font-weight: bold;
    margin-left: 4px;
  }
  .selection-status {
    background: rgba(78, 161, 255, 0.15);
    border: 1px solid var(--accent);
    border-radius: 8px;
    padding: 8px 12px;
    margin-bottom: 8px;
    font-size: 13px;
  }
  .selection-status .status-label {
    color: var(--muted);
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  .selection-status .player-name {
    font-weight: bold;
    color: var(--ink);
  }
  .selection-status .out-player { color: var(--over); }
  .selection-status .in-player { color: var(--ok); }
</style>
</head>
<body>
<header>
  <h1>Sideline Timekeeper</h1>
  <div class="grow"></div>
  <div class="toolbar">
    <button class="btn" id="btnSetup">Setup</button>
    <button class="btn" id="btnPlayers">Players</button>
    <button class="btn" id="btnFormations">Formations</button>
    <button class="btn" id="btnLineup">Lineup</button>
    <button class="btn" id="btnGame">Game</button>
    <button class="btn" id="btnReports">Reports</button>
  </div>
</header>

<div class="wrap">

  <!-- Setup -->
  <section class="panel" id="viewSetup">
    <div class="section-title">1) Roster</div>
    <div class="grid cols-2">
      <div>
        <label class="hint">Enter one per line: <b>Name[,Number][,Preferred (e.g. ST,MF)]</b></label>
        <textarea id="rosterInput" placeholder="Alice,10,ST&#10;Ben,7,MF,DF&#10;Casey,22,DF&#10;..."></textarea>
        <div class="row">
          <button class="btn" id="btnExample">Use Example 17-Player Roster</button>
          <button class="btn primary" id="btnLoadRoster">Apply Roster</button>
        </div>
      </div>
      <div>
        <div class="section-title">Save / Load Game</div>
        <div class="row">
          <button class="btn" id="btnSave">Save Game (JSON)</button>
          <input type="file" id="fileLoad" accept=".json" class="hidden" />
          <button class="btn" id="btnLoad">Load Game (JSON)</button>
          <button class="btn ghost" id="btnClear">Clear All</button>
        </div>
        <div class="divider"></div>
        <div class="section-title">Scheduled Start & Halftime</div>
        <div class="row">
          <label>Schedule (today, 24h):</label>
          <input id="scheduledHHMM" placeholder="14:30" style="max-width:160px" />
          <button class="btn" id="btnSetSchedule">Set</button>
          <span class="hint" id="scheduledLabel"></span>
        </div>
        <div class="row" style="margin-top:8px">
          <button class="btn" id="btnStart">Start / Resume</button>
          <button class="btn" id="btnPause">Pause</button>
          <button class="btn" id="btnHalftime">Start Halftime (10.5m)</button>
          <button class="btn" id="btnEndHalftime">Force End Halftime</button>
        </div>
        <div class="divider"></div>
        <div class="section-title">Timer Configuration</div>
        <div class="row">
          <label>Regulation Minutes:</label>
          <input id="formatMinutes" type="number" min="10" max="120" step="5" style="max-width:120px" />
          <label>Periods:</label>
          <select id="formatPeriods" style="max-width:140px">
            <option value="1">1 Full Time</option>
            <option value="2" selected>2 Halves</option>
            <option value="3">3 Thirds</option>
            <option value="4">4 Quarters</option>
          </select>
          <button class="btn" id="btnApplyFormat">Apply Format</button>
        </div>
        <div class="row" style="margin-top:8px">
          <label>Manual Time:</label>
          <select id="adjustKind" style="max-width:180px">
            <option value="adjustment">Adjustment (+/-)</option>
            <option value="stoppage">Stoppage / Injury</option>
          </select>
          <select id="adjustPeriod" style="max-width:160px"></select>
          <input id="adjustSeconds" placeholder="Seconds" style="max-width:120px" />
          <label class="hint"><input type="checkbox" id="adjustAll" style="margin-right:4px" />All periods</label>
          <button class="btn" id="btnApplyManual">Apply</button>
        </div>
        <p class="hint">Tip: Save at kickoff, halftime, and full time. State also persists in your browser (localStorage).</p>
      </div>
    </div>
  </section>

  <!-- Players -->
  <section class="panel hidden" id="viewPlayers">
    <div class="section-title">Player Management</div>
    
    <!-- Player Actions Toolbar -->
    <div class="toolbar">
      <button class="btn primary" id="btnAddPlayer">Add Player</button>
      <button class="btn" id="btnImportPlayers">Import Players</button>
      <button class="btn" id="btnExportPlayers">Export Players</button>
      <button class="btn" id="btnUpdateStats">Update Statistics</button>
      <button class="btn" id="btnMarkAttendance">Mark Attendance</button>
    </div>
    
    <div class="grid cols-2" style="margin-top: 12px;">
      <!-- Player List -->
      <div>
        <div class="section-title">Team Roster</div>
        <table id="playersTable">
          <thead>
            <tr>
              <th>Name</th>
              <th>#</th>
              <th>Age</th>
              <th>Positions</th>
              <th>Games</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="playersTableBody">
            <!-- Players will be populated here -->
          </tbody>
        </table>
      </div>
      
      <!-- Player Details Panel -->
      <div>
        <div class="section-title">Player Details</div>
        <div id="playerDetailsPanel">
          <p class="hint">Select a player from the list to view details</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Formations -->
  <section class="panel hidden" id="viewFormations">
    <div class="section-title">Formation Editor & Tactical Planning</div>
    
    <div class="grid cols-2">
      <!-- Left Panel - Formation Management -->
      <div>
        <div class="section-title">Formation Management</div>
        
        <!-- Formation Selection -->
        <div class="panel">
          <div class="section-title">Select Formation</div>
          <select id="formationSelect" style="margin-bottom:12px;">
            <option value="">-- Select Formation --</option>
          </select>
          
          <div class="row" style="margin-bottom:8px;">
            <button class="btn" id="btnNewFormation">New</button>
            <button class="btn" id="btnFromTemplate">From Template</button>
            <button class="btn" id="btnDeleteFormation">Delete</button>
          </div>
        </div>
        
        <!-- Formation Details -->
        <div class="panel">
          <div class="section-title">Formation Details</div>
          <div style="margin-bottom:8px;">
            <label class="hint">Name</label>
            <input id="formationName" placeholder="Formation name" />
          </div>
          <div style="margin-bottom:8px;">
            <label class="hint">Type</label>
            <select id="formationType">
              <option value="4-4-2">4-4-2</option>
              <option value="4-3-3">4-3-3</option>
              <option value="3-5-2">3-5-2</option>
              <option value="4-5-1">4-5-1</option>
              <option value="3-4-3">3-4-3</option>
              <option value="5-3-2">5-3-2</option>
              <option value="custom">Custom</option>
            </select>
          </div>
          <div style="margin-bottom:12px;">
            <label class="hint">Description</label>
            <textarea id="formationDescription" placeholder="Formation description..." rows="3"></textarea>
          </div>
          <div class="row">
            <button class="btn primary" id="btnSaveFormation">Save Formation</button>
          </div>
        </div>
        
        <!-- Quick Actions -->
        <div class="panel">
          <div class="section-title">Quick Actions</div>
          <button class="btn" id="btnAutoAssign" style="width:100%; margin-bottom:8px;">Auto-Assign Players</button>
          <button class="btn ghost" id="btnClearAssignments" style="width:100%; margin-bottom:8px;">Clear All Assignments</button>
          <button class="btn" id="btnSuggestFormation" style="width:100%;">Suggest Formation</button>
        </div>
      </div>
      
      <!-- Right Panel - Field Visualization -->
      <div>
        <div class="section-title">Field Visualization</div>
        <div class="panel">
          <div id="fieldContainer" style="position:relative; width:100%; height:400px; background:linear-gradient(to bottom, #4a8f3a 0%, #2d6b22 100%); border:2px solid white; border-radius:8px; overflow:hidden;">
            <!-- Field markings will be drawn here -->
            <div id="fieldMarkings" style="position:absolute; inset:0; pointer-events:none;"></div>
            <div id="formationPositions" style="position:absolute; inset:0;"></div>
          </div>
          
          <div style="margin-top:12px; text-align:center;">
            <div id="formationInfo" class="hint">No formation selected</div>
          </div>
        </div>
        
        <!-- Player Assignment -->
        <div class="panel">
          <div class="section-title">Player Assignments</div>
          <div id="positionAssignments" style="max-height:200px; overflow-y:auto;">
            <div class="hint">Select a formation to assign players</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Formation Templates Modal -->
    <div id="templateModal" class="hidden" style="position:fixed; inset:0; background:rgba(0,0,0,0.7); display:flex; align-items:center; justify-content:center; z-index:1000;">
      <div class="panel" style="width:500px; max-height:80vh; overflow-y:auto;">
        <div class="section-title">Select Formation Template</div>
        <div id="templateList" style="margin-bottom:16px;">
          <!-- Template options will be populated here -->
        </div>
        <div style="margin-bottom:16px;">
          <label class="hint">Name for new formation</label>
          <input id="templateFormationName" placeholder="Enter formation name" />
        </div>
        <div class="row">
          <button class="btn ghost" id="btnCancelTemplate">Cancel</button>
          <button class="btn primary" id="btnCreateFromTemplate">Create Formation</button>
        </div>
      </div>
    </div>
  </section>

  <!-- Lineup -->
  <section class="panel hidden" id="viewLineup">
    <div class="section-title">2) Pick Starting Lineup (1 GK, 3 DF, 2 MF, 3 ST)</div>
    <div class="grid cols-3">
      <div>
        <div class="section-title">Required Slots</div>
        <ul id="slotList" style="list-style:none;padding:0;margin:0"></ul>
      </div>
      <div>
        <div class="section-title">Roster</div>
        <table id="rosterTable">
          <thead><tr><th>Name</th><th>#</th><th>Preferred</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <div class="section-title">Assignments</div>
        <table id="assignTable">
          <thead><tr><th>Slot</th><th>Player</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
    <div class="sticky-footer row" style="justify-content:space-between">
      <span class="hint">Tap a slot â†’ tap a player to assign. Duplicate prevention included.</span>
      <div class="row">
        <button class="btn ghost" id="btnClearAssign">Clear All</button>
        <button class="btn primary" id="btnStartGame">Start Game</button>
      </div>
    </div>
  </section>

  <!-- Game -->
  <section class="panel hidden" id="viewGame">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <div class="row" style="gap:12px">
        <div class="pill" id="clockLabel">00:00 / 60:00</div>
        <div class="pill" id="statusLabel">PAUSED</div>
        <div class="pill" id="periodPill">1st Half</div>
        <div class="pill" id="metaPill">Stoppage 00:00 â€¢ Adjust +00:00</div>
        <div class="pill" id="halfLabel" style="display:none">BREAK</div>
        <div class="pill" id="schedLabel" style="display:none">Starts in 00:00</div>
      </div>
      <div class="row">
        <button class="btn" id="gStart">Start/Resume</button>
        <button class="btn" id="gPause">Pause</button>
        <button class="btn" id="gHalf">Halftime (10.5m)</button>
        <button class="btn" id="gSave">Save</button>
      </div>
      <div class="row" style="margin-top:8px; padding-top:8px; border-top:1px solid var(--line);">
        <span class="section-title" style="margin-bottom:0;">Quick Actions:</span>
        <button class="btn ghost" id="gStoppage30" onclick="apiAddStoppageTime(30)">+30s Stop</button>
        <button class="btn ghost" id="gStoppage60" onclick="apiAddStoppageTime(60)">+1m Stop</button>
        <button class="btn ghost" id="gAdjustMin" onclick="apiAddTimeAdjustment(-60)">-1m Adj</button>
        <button class="btn ghost" id="gAdjustPlus" onclick="apiAddTimeAdjustment(60)">+1m Adj</button>
      </div>
    </div>

    <div class="panel" style="margin-top:12px">
      <div class="section-title">Period Summary</div>
      <table id="periodTable">
        <thead>
          <tr><th>Period</th><th>Reg</th><th>Elapsed</th><th>Adj</th><th>Stop</th><th>Remain</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="grid cols-2" style="margin-top:12px">
      <div class="panel">
        <div class="section-title">On Field</div>
        <table id="onFieldTable">
          <thead>
            <tr><th>Pos</th><th>Name</th><th>#</th><th>Stint</th><th>Total</th><th>Pref</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="panel">
        <div class="section-title">Roster / Choose Replacement</div>
        <table id="rosterGameTable">
          <thead>
            <tr><th>Name</th><th>#</th><th>Status</th><th>Pos</th><th>Stint</th><th>Total</th><th>Pref</th></tr>
          </thead>
          <tbody></tbody>
        </table>
        <div class="divider"></div>
        
        <!-- Selection Status Display -->
        <div id="selectionStatus" class="selection-status" style="display:none;">
          <div class="row" style="justify-content:space-between;">
            <div>
              <span class="status-label">Subbing Out:</span>
              <span class="player-name out-player" id="outPlayerDisplay">None</span>
            </div>
            <div style="font-size:20px;">âžœ</div>
            <div>
              <span class="status-label">Subbing In:</span>
              <span class="player-name in-player" id="inPlayerDisplay">None</span>
            </div>
          </div>
        </div>
        
        <div class="row" style="justify-content:space-between;margin-top:8px;">
          <div class="hint">Click a player in "On Field" to select OUT, then click a player in "Roster" to select IN.</div>
          <div class="row">
            <button class="btn" id="btnQueue">Queue Selected</button>
            <button class="btn" id="btnClearQueue">Clear Queue</button>
            <button class="btn primary" id="btnCommit">Commit Subs</button>
          </div>
        </div>
        <div id="queueList" style="margin-top:8px"></div>
      </div>
    </div>
  </section>

  <!-- Reports -->
  <section class="panel hidden" id="viewReports">
    <div class="section-title">4) Playing Time Analytics</div>
    <div class="grid cols-2">
      <div class="panel" style="min-height:120px">
        <div class="section-title">Summary</div>
        <p class="accent" id="reportSummary">Add players to view analytics.</p>
        <p class="hint" id="reportDetail"></p>
        <p class="hint" id="reportDistribution"></p>
      </div>
      <div class="panel" style="min-height:120px">
        <div class="section-title">Targets</div>
        <p class="hint" id="reportTargets"></p>
        <p class="hint" id="reportElapsed"></p>
        <div style="margin-top: 10px;">
          <button class="btn ghost" onclick="exportReportCSV()" title="Export detailed report as CSV">
            ðŸ“Š Export CSV
          </button>
        </div>
      </div>
    </div>
    <div class="row" style="justify-content:flex-end;margin-top:12px">
      <button class="btn" id="btnReportExport">Export CSV</button>
    </div>
    <div class="divider"></div>
    <table id="reportTable">
      <thead>
        <tr>
          <th>Name</th>
          <th>#</th>
          <th>Preferred</th>
          <th>Status</th>
          <th>Played</th>
          <th>Target</th>
          <th>Delta</th>
          <th>Share</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <p class="hint" id="reportNote">Delta compares playing time against an equal share of regulation, stoppage, and adjustments.</p>
  </section>

</div>

<script>
/** -------------------------
 *  API Communication Layer
 *  ------------------------- */
const API_BASE = '/api';

// API communication functions for enhanced features
async function apiCall(endpoint, method = 'GET', data = null) {
  try {
    const options = {
      method,
      headers: {},
    };
    
    // Only set JSON headers and body if we have data to send
    if (data) {
      options.headers['Content-Type'] = 'application/json';
      options.body = JSON.stringify(data);
    }
    
    const response = await fetch(`${API_BASE}${endpoint}`, options);
    const result = await response.json();
    
    if (!result.success) {
      console.error('API Error:', result.error);
      showNotification(result.error || 'API request failed', 'error');
    }
    
    return result;
  } catch (error) {
    console.error('Network error:', error);
    showNotification('Network error', 'error');
    return {success: false, error: error.message};
  }
}

// Enhanced timer control functions using API
async function apiStartGame() {
  const result = await apiCall('/timer/start', 'POST');
  if (result.success) {
    showNotification('Game started', 'success');
    refreshFromAPI();
  } else {
    // Handle specific validation errors
    if (result.validation_errors && result.validation_errors.length > 0) {
      const errorMsg = result.validation_errors.join(', ');
      console.warn('Validation errors:', errorMsg);
      showNotification(`Cannot start game: ${errorMsg}`, 'error');
      
      // If this is a roster issue, clear any scheduled start to prevent loops
      if (errorMsg.includes('roster') || errorMsg.includes('players')) {
        console.warn('Clearing scheduled start due to roster validation failure');
        state.scheduledStartTs = null;
        saveLocal();
      }
    } else {
      showNotification(result.error || 'Failed to start game', 'error');
    }
    
    // Ensure API errors are properly propagated as promise rejections
    const error = new Error(result.error || 'Failed to start game');
    throw error;
  }
}

async function apiPauseGame() {
  const result = await apiCall('/timer/pause', 'POST');
  if (result.success) {
    showNotification('Game paused', 'success');
    refreshFromAPI();
  }
}

async function apiStartHalftime() {
  const result = await apiCall('/timer/halftime', 'POST');
  if (result.success) {
    showNotification('Halftime started', 'success');
    refreshFromAPI();
  }
}

async function apiAddStoppageTime(seconds) {
  const result = await apiCall('/timer/stoppage', 'POST', {seconds});
  if (result.success) {
    showNotification(`Added ${seconds}s stoppage time`, 'success');
    refreshFromAPI();
  }
}

async function apiAddTimeAdjustment(seconds, periodIndex = null, applyToAll = false) {
  const result = await apiCall('/timer/adjustment', 'POST', {
    seconds, 
    period_index: periodIndex, 
    apply_to_all: applyToAll
  });
  if (result.success) {
    showNotification(`Added ${seconds}s time adjustment`, 'success');
    refreshFromAPI();
  }
}

async function apiConfigureTimer(minutes, periods) {
  const result = await apiCall('/timer/configure', 'POST', {minutes, periods});
  if (result.success) {
    showNotification('Timer configured', 'success');
    refreshFromAPI();
  }
}

async function apiMakeSubstitution(outName, inName) {
  const result = await apiCall('/substitution', 'POST', {out_name: outName, in_name: inName});
  if (result.success) {
    showNotification(`Substituted ${outName} for ${inName}`, 'success');
    refreshFromAPI();
  }
}

async function exportReportCSV() {
  try {
    const response = await fetch('/api/analytics/export', {
      method: 'GET',
    });
    
    if (!response.ok) {
      throw new Error('Failed to export report');
    }
    
    // Get the filename from the response headers
    const contentDisposition = response.headers.get('content-disposition');
    let filename = 'game_report.csv';
    if (contentDisposition) {
      const match = contentDisposition.match(/filename="(.+)"/);
      if (match) filename = match[1];
    }
    
    // Download the file
    const blob = await response.blob();
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    showNotification('Report exported successfully', 'success');
  } catch (error) {
    console.error('Export failed:', error);
    showNotification('Failed to export report', 'error');
  }
}

async function refreshFromAPI() {
  const result = await apiCall('/state');
  if (result.success) {
    // Update local state with server data
    updateLocalStateFromAPI(result);
    renderGame();
  }
}

function updateLocalStateFromAPI(apiData) {
  // Update local state with data from API
  const gameState = apiData.game_state;
  const players = apiData.players;
  
  // Update timer state
  state.paused = gameState.paused;
  state.gameStartTs = gameState.game_started ? Date.now() / 1000 - gameState.elapsed_seconds : null;
  state.periodCount = gameState.period_count;
  
  // Update players
  state.players = players.map(p => ({
    name: p.name,
    number: p.number,
    preferred: p.preferred_positions,
    totalSec: p.total_seconds,
    onField: p.on_field,
    position: p.position,
    stintStart: p.on_field && !gameState.paused ? Date.now() / 1000 : null
  }));
}

function showNotification(message, type = 'info') {
  // Simple notification system
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.textContent = message;
  notification.style.cssText = `
    position: fixed; top: 20px; right: 20px; z-index: 1000;
    padding: 12px 20px; border-radius: 8px; color: white;
    background: ${type === 'success' ? '#24c88b' : type === 'error' ? '#ff6b6b' : '#4ea1ff'};
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
  `;
  
  document.body.appendChild(notification);
  setTimeout(() => {
    notification.style.opacity = '0';
    notification.style.transform = 'translateY(-20px)';
    setTimeout(() => document.body.removeChild(notification), 300);
  }, 3000);
}

/** -------------------------
 *  Data Model & Utilities
 *  ------------------------- */
const GAME_LENGTH_MIN = 60;
const HALFTIME_MIN = 10.5;
const PERIOD_LABELS = {1: "Full Time", 2: "Half", 3: "Third", 4: "Quarter"};
const REQUIRED_SLOTS = ["GK","DF","DF","DF","MF","MF","ST","ST","ST"];
const POS_FULL = {GK:"Goalkeeper", DF:"Defender", MF:"Midfielder", ST:"Striker"};
const FAIRNESS_THRESHOLD = 120; // seconds

let state = {
  players: [], // {name, number, preferred, totalSec, onField, position, stintStart}
  gameStartTs: null,
  paused: true,
  breakActive: false,
  halftimeEndTs: null,
  scheduledStartTs: null,
  elapsedAdjustment: 0, // legacy aggregate
  gameLengthSec: GAME_LENGTH_MIN * 60,
  periodCount: 2,
  periodElapsed: [],
  periodAdjust: [],
  periodStoppage: [],
  currentPeriodIndex: 0,
  periodStartTs: null
};

function ordinal(n) {
  const rem100 = n % 100;
  if (rem100 >= 11 && rem100 <= 13) return `${n}th`;
  const rem10 = n % 10;
  const suffix = rem10 === 1 ? "st" : rem10 === 2 ? "nd" : rem10 === 3 ? "rd" : "th";
  return `${n}${suffix}`;
}

function describePeriodLabel(number, total) {
  const base = PERIOD_LABELS[total] || "Period";
  if (total <= 1) return base;
  return `${ordinal(number)} ${base}`;
}

function ensurePeriodArrays() {
  const count = Math.max(1, state.periodCount | 0);
  state.periodCount = count;
  const expand = (arr) => {
    if (!Array.isArray(arr)) arr = [];
    if (arr.length < count) {
      return arr.concat(Array(count - arr.length).fill(0));
    }
    if (arr.length > count) {
      return arr.slice(0, count);
    }
    return arr;
  };
  state.periodElapsed = expand(state.periodElapsed);
  state.periodAdjust = expand(state.periodAdjust);
  state.periodStoppage = expand(state.periodStoppage);
  if (state.currentPeriodIndex >= count) {
    state.currentPeriodIndex = count - 1;
  }
}

function normalizeState() {
  state.gameLengthSec = Number(state.gameLengthSec || GAME_LENGTH_MIN * 60);
  state.periodCount = Number(state.periodCount || 2);
  state.elapsedAdjustment = Number(state.elapsedAdjustment || 0);
  if (typeof state.currentPeriodIndex !== "number") state.currentPeriodIndex = 0;
  if (typeof state.periodStartTs !== "number") state.periodStartTs = null;
  state.breakActive = Boolean(state.breakActive);
  ensurePeriodArrays();
}

function totalAdjustmentSeconds() {
  ensurePeriodArrays();
  return state.periodAdjust.slice(0, state.periodCount).reduce((sum, v) => sum + (v | 0), 0);
}

function recalcAggregateAdjustment() {
  state.elapsedAdjustment = totalAdjustmentSeconds();
}

function totalStoppageSeconds() {
  ensurePeriodArrays();
  return state.periodStoppage.slice(0, state.periodCount).reduce((sum, v) => sum + (v | 0), 0);
}

function targetSecondsTotal() {
  return Math.max(0, state.gameLengthSec + totalStoppageSeconds() + totalAdjustmentSeconds());
}

function targetSecondsPerPlayer() {
  const rosterSize = Math.max(1, state.players.length);
  return targetSecondsTotal() / rosterSize;
}

function baseElapsedSeconds(includeRunning = true) {
  ensurePeriodArrays();
  let total = state.periodElapsed.slice(0, state.periodCount).reduce((sum, v) => sum + (v | 0), 0);
  if (includeRunning && state.periodStartTs && !state.paused && !state.breakActive) {
    total += Math.max(0, nowSec() - state.periodStartTs);
  }
  if (total === 0 && state.gameStartTs) {
    total = Math.max(0, nowSec() - state.gameStartTs);
  }
  return total;
}

function gameElapsedSeconds() {
  return baseElapsedSeconds() + totalAdjustmentSeconds() + totalStoppageSeconds();
}

function periodTargetSeconds(index) {
  ensurePeriodArrays();
  const count = state.periodCount;
  const base = Math.floor(state.gameLengthSec / count);
  const remainder = state.gameLengthSec % count;
  const reg = base + (index < remainder ? 1 : 0);
  return reg + (state.periodAdjust[index] | 0) + (state.periodStoppage[index] | 0);
}

function periodRegulationSeconds(index) {
  const count = state.periodCount;
  const base = Math.floor(state.gameLengthSec / count);
  const remainder = state.gameLengthSec % count;
  return base + (index < remainder ? 1 : 0);
}

function periodRemainingSeconds(index) {
  const target = periodTargetSeconds(index);
  const elapsed = state.periodElapsed[index] + (index === state.currentPeriodIndex && state.periodStartTs && !state.paused && !state.breakActive ? Math.max(0, nowSec() - state.periodStartTs) : 0);
  return Math.max(0, target - elapsed);
}

normalizeState();

let ui = {
  // nav
  btnSetup: document.getElementById("btnSetup"),
  btnLineup: document.getElementById("btnLineup"),
  btnGame: document.getElementById("btnGame"),
  btnReports: document.getElementById("btnReports"),
  btnPlayers: document.getElementById("btnPlayers"),
  btnFormations: document.getElementById("btnFormations"),
  viewSetup: document.getElementById("viewSetup"),
  viewLineup: document.getElementById("viewLineup"),
  viewGame: document.getElementById("viewGame"),
  viewReports: document.getElementById("viewReports"),
  viewPlayers: document.getElementById("viewPlayers"),
  viewFormations: document.getElementById("viewFormations"),

  // setup
  rosterInput: document.getElementById("rosterInput"),
  btnExample: document.getElementById("btnExample"),
  btnLoadRoster: document.getElementById("btnLoadRoster"),
  btnSave: document.getElementById("btnSave"),
  btnLoad: document.getElementById("btnLoad"),
  btnClear: document.getElementById("btnClear"),
  fileLoad: document.getElementById("fileLoad"),
  scheduledHHMM: document.getElementById("scheduledHHMM"),
  btnSetSchedule: document.getElementById("btnSetSchedule"),
  scheduledLabel: document.getElementById("scheduledLabel"),
  btnStart: document.getElementById("btnStart"),
  btnPause: document.getElementById("btnPause"),
  btnHalftime: document.getElementById("btnHalftime"),
  btnEndHalftime: document.getElementById("btnEndHalftime"),
  formatMinutes: document.getElementById("formatMinutes"),
  formatPeriods: document.getElementById("formatPeriods"),
  btnApplyFormat: document.getElementById("btnApplyFormat"),
  adjustKind: document.getElementById("adjustKind"),
  adjustPeriod: document.getElementById("adjustPeriod"),
  adjustSeconds: document.getElementById("adjustSeconds"),
  adjustAll: document.getElementById("adjustAll"),
  btnApplyManual: document.getElementById("btnApplyManual"),

  // lineup
  slotList: document.getElementById("slotList"),
  rosterTable: document.querySelector("#rosterTable tbody"),
  assignTable: document.querySelector("#assignTable tbody"),
  btnClearAssign: document.getElementById("btnClearAssign"),
  btnStartGame: document.getElementById("btnStartGame"),

  // game
  clockLabel: document.getElementById("clockLabel"),
  statusLabel: document.getElementById("statusLabel"),
  periodPill: document.getElementById("periodPill"),
  metaPill: document.getElementById("metaPill"),
  halfLabel: document.getElementById("halfLabel"),
  schedLabel: document.getElementById("schedLabel"),
  gStart: document.getElementById("gStart"),
  gPause: document.getElementById("gPause"),
  gHalf: document.getElementById("gHalf"),
  gSave: document.getElementById("gSave"),
  periodTable: document.querySelector("#periodTable tbody"),
  onFieldTable: document.querySelector("#onFieldTable tbody"),
  rosterGameTable: document.querySelector("#rosterGameTable tbody"),
  btnQueue: document.getElementById("btnQueue"),
  btnClearQueue: document.getElementById("btnClearQueue"),
  btnCommit: document.getElementById("btnCommit"),
  queueList: document.getElementById("queueList"),

  // reports
  btnReportExport: document.getElementById("btnReportExport"),
  reportSummary: document.getElementById("reportSummary"),
  reportDetail: document.getElementById("reportDetail"),
  reportDistribution: document.getElementById("reportDistribution"),
  reportTargets: document.getElementById("reportTargets"),
  reportElapsed: document.getElementById("reportElapsed"),
  reportTable: document.querySelector("#reportTable tbody"),
  reportNote: document.getElementById("reportNote"),

  // players
  playersTable: document.querySelector("#playersTable tbody"),
  playerDetails: document.getElementById("playerDetails"),
  btnAddPlayer: document.getElementById("btnAddPlayer"),
  btnEditPlayer: document.getElementById("btnEditPlayer"),
  btnDeletePlayer: document.getElementById("btnDeletePlayer"),
  btnImportPlayers: document.getElementById("btnImportPlayers"),
  btnExportPlayers: document.getElementById("btnExportPlayers"),
  btnPlayerStats: document.getElementById("btnPlayerStats"),
  btnAttendance: document.getElementById("btnAttendance"),

  // formations
  formationSelect: document.getElementById("formationSelect"),
  formationName: document.getElementById("formationName"),
  formationType: document.getElementById("formationType"),
  formationDescription: document.getElementById("formationDescription"),
  btnNewFormation: document.getElementById("btnNewFormation"),
  btnFromTemplate: document.getElementById("btnFromTemplate"),
  btnDeleteFormation: document.getElementById("btnDeleteFormation"),
  btnSaveFormation: document.getElementById("btnSaveFormation"),
  btnAutoAssign: document.getElementById("btnAutoAssign"),
  btnClearAssignments: document.getElementById("btnClearAssignments"),
  btnSuggestFormation: document.getElementById("btnSuggestFormation"),
  fieldContainer: document.getElementById("fieldContainer"),
  fieldMarkings: document.getElementById("fieldMarkings"),
  formationPositions: document.getElementById("formationPositions"),
  formationInfo: document.getElementById("formationInfo"),
  positionAssignments: document.getElementById("positionAssignments"),
  templateModal: document.getElementById("templateModal"),
  templateList: document.getElementById("templateList"),
  templateFormationName: document.getElementById("templateFormationName"),
  btnCancelTemplate: document.getElementById("btnCancelTemplate"),
  btnCreateFromTemplate: document.getElementById("btnCreateFromTemplate"),
};

let selectedSlotIndex = null;  // for lineup
let selectedOutName = null;    // in-game OUT selection
let selectedInName = null;     // in-game IN selection
let subQueue = [];             // [{out,in}]
let tickHandle = null;
let latestReportSnapshot = null;

function nowSec() { return Math.floor(Date.now()/1000); }
function fmtMMSS(sec) { sec = Math.max(0, sec|0); const m = Math.floor(sec/60), s = sec%60; return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`; }
function fmtSignedMMSS(sec) { const sign = sec >= 0 ? "+" : "-"; return sign + fmtMMSS(Math.abs(sec)); }
function saveLocal() {
  recalcAggregateAdjustment();
  localStorage.setItem("sideline_state", JSON.stringify(state));
}
function loadLocal() {
  const s = localStorage.getItem("sideline_state");
  if (s) {
    try {
      state = JSON.parse(s);
    } catch (err) {
      console.warn("Failed to parse saved state", err);
    }
  }
  normalizeState();
  recalcAggregateAdjustment();
}
function resetAll() {
  state = {
    players: [],
    gameStartTs: null,
    paused: true,
    breakActive: false,
    halftimeEndTs: null,
    scheduledStartTs: null,
    elapsedAdjustment: 0,
    gameLengthSec: GAME_LENGTH_MIN * 60,
    periodCount: 2,
    periodElapsed: [],
    periodAdjust: [],
    periodStoppage: [],
    currentPeriodIndex: 0,
    periodStartTs: null
  };
  normalizeState();
  subQueue = []; selectedOutName = null; selectedInName = null; selectedSlotIndex = null;
  saveLocal(); renderAll();
}

function fairnessClass(totalSec, targetSec = targetSecondsPerPlayer()) {
  const delta = totalSec - targetSec;
  if (delta <= -FAIRNESS_THRESHOLD) return "under";
  if (delta >= FAIRNESS_THRESHOLD) return "over";
  return "ok";
}

function currentStint(p) {
  if (p.onField && p.stintStart) return nowSec() - p.stintStart;
  return 0;
}

function totalLive(p) {
  return (p.totalSec|0) + currentStint(p);
}

function median(values) {
  if (!values.length) return 0;
  const sorted = values.slice().sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  if (sorted.length % 2 === 0) {
    return (sorted[mid - 1] + sorted[mid]) / 2;
  }
  return sorted[mid];
}

function csvEscape(value) {
  if (value === null || value === undefined) return "";
  const str = String(value);
  if (/[",\n]/.test(str)) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

function reportSnapshotToCsv(snapshot) {
  const lines = [];
  const iso = new Date(snapshot.generatedTs * 1000).toISOString();
  lines.push(["Sideline Timekeeper Report"]);
  lines.push(["Generated", iso]);
  lines.push(["Roster Size", snapshot.rosterSize]);
  lines.push(["Elapsed Seconds", Math.round(snapshot.elapsed)]);
  lines.push(["Regulation Seconds", Math.round(snapshot.regulationSeconds)]);
  lines.push(["Stoppage Seconds", Math.round(snapshot.stoppage)]);
  lines.push(["Adjustment Seconds", Math.round(snapshot.adjustments)]);
  lines.push(["Target Seconds Total", Math.round(snapshot.totalTarget)]);
  lines.push(["Target Seconds Per Player", Math.round(snapshot.perPlayerRounded)]);
  lines.push(["Average Seconds", Math.round(snapshot.average * 100) / 100]);
  lines.push(["Median Seconds", Math.round(snapshot.median * 100) / 100]);
  lines.push(["Minimum Seconds", Math.round(snapshot.min)]);
  lines.push(["Maximum Seconds", Math.round(snapshot.max)]);
  const fairnessCounts = snapshot.fairnessCounts || { under: 0, ok: 0, over: 0 };
  lines.push(["Players Under Target", fairnessCounts.under || 0]);
  lines.push(["Players On Target", fairnessCounts.ok || 0]);
  lines.push(["Players Over Target", fairnessCounts.over || 0]);
  lines.push([]);
  lines.push([
    "Name",
    "Number",
    "Preferred Positions",
    "On Field",
    "Position",
    "Total Seconds",
    "Active Stint Seconds",
    "Cumulative Seconds",
    "Target Seconds",
    "Delta Seconds",
    "Bench Seconds",
    "Target Share (%)",
    "Fairness",
  ]);

  snapshot.rows.forEach((row) => {
    lines.push([
      row.name,
      row.number,
      row.preferredList.join(", "),
      row.onField ? "yes" : "no",
      row.position,
      row.totalSeconds,
      row.activeSeconds,
      row.cumulativeSeconds,
      row.targetSeconds,
      row.deltaSeconds,
      row.benchSeconds,
      Math.round(row.targetSharePercent * 100) / 100,
      row.fairness,
    ]);
  });

  return lines.map((line) => line.map(csvEscape).join(",")).join("\n") + "\n";
}

function buildReportSnapshot() {
  ensurePeriodArrays();
  const roster = state.players.slice();
  if (!roster.length) {
    latestReportSnapshot = null;
    return null;
  }

  const generatedTs = nowSec();
  const elapsed = gameElapsedSeconds();
  const totalTarget = targetSecondsTotal();
  const perPlayerTarget = targetSecondsPerPlayer();
  const perPlayerRounded = Math.round(perPlayerTarget);
  const stoppage = totalStoppageSeconds();
  const adjustments = totalAdjustmentSeconds();
  const regulation = state.gameLengthSec;
  const totals = roster.map(totalLive);
  const average = totals.length
    ? totals.reduce((sum, value) => sum + value, 0) / totals.length
    : 0;
  const med = median(totals);
  const minVal = totals.length ? Math.min(...totals) : 0;
  const maxVal = totals.length ? Math.max(...totals) : 0;
  const fairnessOrder = { under: 0, ok: 1, over: 2 };

  const rows = roster.map((player) => {
    const preferredList = (player.preferred || "")
      .split(",")
      .map((s) => s.trim().toUpperCase())
      .filter((s) => s.length);
    const total = totalLive(player);
    const delta = Math.round(total - perPlayerTarget);
    const fairness = fairnessClass(total, perPlayerTarget);
    const share = perPlayerTarget > 0 ? (total / perPlayerTarget) * 100 : 0;
    const status = player.onField
      ? `On Field${player.position ? ` (${player.position})` : ""}`
      : "Bench";
    const benchSeconds = Math.max(0, elapsed - total);
    const activeSeconds = currentStint(player);
    return {
      name: player.name,
      number: player.number || "",
      preferredList,
      preferredDisplay: preferredList.join(", "),
      onField: !!player.onField,
      position: player.position || "",
      totalSeconds: Math.max(0, player.totalSec | 0),
      activeSeconds,
      cumulativeSeconds: total,
      targetSeconds: perPlayerRounded,
      deltaSeconds: delta,
      benchSeconds,
      targetSharePercent: share,
      fairness,
      status,
    };
  });

  rows.sort((a, b) => {
    if (fairnessOrder[a.fairness] !== fairnessOrder[b.fairness]) {
      return fairnessOrder[a.fairness] - fairnessOrder[b.fairness];
    }
    if (a.deltaSeconds !== b.deltaSeconds) {
      return a.deltaSeconds - b.deltaSeconds;
    }
    return a.name.localeCompare(b.name);
  });

  const fairnessCounts = { under: 0, ok: 0, over: 0 };
  rows.forEach((row) => {
    const key = row.fairness;
    fairnessCounts[key] = (fairnessCounts[key] || 0) + 1;
  });

  latestReportSnapshot = {
    generatedTs,
    rosterSize: roster.length,
    elapsed,
    totalTarget,
    perPlayerTarget,
    perPlayerRounded,
    stoppage,
    adjustments,
    regulationSeconds: regulation,
    average,
    median: med,
    min: minVal,
    max: maxVal,
    rows,
    fairnessCounts,
  };
  return latestReportSnapshot;
}

function downloadReportCsv() {
  const snapshot = buildReportSnapshot();
  if (!snapshot) {
    alert("Add players before exporting analytics.");
    return;
  }

  const csv = reportSnapshotToCsv(snapshot);
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  const stamp = new Date(snapshot.generatedTs * 1000)
    .toISOString()
    .replace(/[:.]/g, "-");
  const link = document.createElement("a");
  link.href = url;
  link.download = `sideline_report_${stamp}.csv`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/** -------------------------
 *  Navigation & Views
 *  ------------------------- */
function show(view) {
  const views = {
    setup: ui.viewSetup,
    players: ui.viewPlayers,
    formations: ui.viewFormations,
    lineup: ui.viewLineup,
    game: ui.viewGame,
    reports: ui.viewReports,
  };
  Object.entries(views).forEach(([key, el]) => {
    if (!el) return;
    el.classList.toggle("hidden", view !== key);
  });
  const buttons = {
    setup: ui.btnSetup,
    players: ui.btnPlayers,
    formations: ui.btnFormations,
    lineup: ui.btnLineup,
    game: ui.btnGame,
    reports: ui.btnReports,
  };
  Object.entries(buttons).forEach(([key, btn]) => {
    if (!btn) return;
    btn.classList.toggle("primary", view === key);
  });
}

ui.btnSetup.onclick = () => { show("setup"); };
ui.btnPlayers.onclick = () => { show("players"); renderPlayers(); };
ui.btnFormations.onclick = () => { show("formations"); renderFormations(); };
ui.btnLineup.onclick = () => { show("lineup"); renderLineup(); };
ui.btnGame.onclick = () => { show("game"); renderGame(); };
ui.btnReports.onclick = () => { show("reports"); renderReports(); };
if (ui.btnReportExport) ui.btnReportExport.onclick = downloadReportCsv;

// Player management button handlers
if (ui.btnAddPlayer) ui.btnAddPlayer.onclick = addPlayer;
if (ui.btnEditPlayer) ui.btnEditPlayer.onclick = editPlayer;
if (ui.btnDeletePlayer) ui.btnDeletePlayer.onclick = deletePlayer;
if (ui.btnImportPlayers) ui.btnImportPlayers.onclick = importPlayers;
if (ui.btnExportPlayers) ui.btnExportPlayers.onclick = exportPlayers;
if (ui.btnPlayerStats) ui.btnPlayerStats.onclick = showPlayerStats;
if (ui.btnAttendance) ui.btnAttendance.onclick = showAttendance;

// Initially disable buttons that require selection
if (ui.btnEditPlayer) ui.btnEditPlayer.disabled = true;
if (ui.btnDeletePlayer) ui.btnDeletePlayer.disabled = true;
if (ui.btnPlayerStats) ui.btnPlayerStats.disabled = true;
if (ui.btnAttendance) ui.btnAttendance.disabled = true;

// Formation management button handlers
if (ui.btnNewFormation) ui.btnNewFormation.onclick = createNewFormation;
if (ui.btnFromTemplate) ui.btnFromTemplate.onclick = createFromTemplate;
if (ui.btnDeleteFormation) ui.btnDeleteFormation.onclick = deleteFormation;
if (ui.btnSaveFormation) ui.btnSaveFormation.onclick = saveFormation;
if (ui.btnAutoAssign) ui.btnAutoAssign.onclick = autoAssignPlayers;
if (ui.btnClearAssignments) ui.btnClearAssignments.onclick = clearAssignments;
if (ui.btnSuggestFormation) ui.btnSuggestFormation.onclick = suggestFormation;
if (ui.formationSelect) ui.formationSelect.onchange = onFormationSelect;
if (ui.btnCancelTemplate) ui.btnCancelTemplate.onclick = () => ui.templateModal.classList.add("hidden");
if (ui.btnCreateFromTemplate) ui.btnCreateFromTemplate.onclick = createFormationFromTemplate;

/** -------------------------
 *  Setup
 *  ------------------------- */
ui.btnExample.onclick = () => {
  const sample = [];
  for (let i=1;i<=17;i++){
    const pref = (i<=4)?"ST":(i<=8)?"MF":(i<=14)?"DF":"GK";
    sample.push(`Player ${i},${String(i).padStart(2,"0")},${pref}`);
  }
  ui.rosterInput.value = sample.join("\n");
};

ui.btnLoadRoster.onclick = async () => {
  const lines = ui.rosterInput.value.split("\n").map(s=>s.trim()).filter(Boolean);
  const players = [];
  const seen = new Set();
  for (const ln of lines) {
    const parts = ln.split(",").map(s=>s.trim()).filter(s=>s.length);
    const name = parts[0]; if (!name || seen.has(name)) continue;
    seen.add(name);
    const number = parts[1] || "";
    const preferred = parts[2] || "";
    players.push({name, number, preferred, totalSec: 0, onField:false, position:null, stintStart:null});
  }
  if (players.length < 9) { alert("Need at least 9 players."); return; }
  
  // Update client-side state and localStorage
  state.players = players;
  saveLocal();
  
  // Sync with server-side using bulk roster update
  try {
    // Transform client players to server format
    const serverPlayers = players.map(player => ({
      name: player.name,
      number: player.number || "",
      preferred: player.preferred || ""
    }));

    const response = await fetch('/api/roster', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ players: serverPlayers })
    });

    const result = await response.json();
    
    if (response.ok && result.success) {
      alert(`Roster loaded and synced with server! ${result.message}`);
    } else {
      console.error('Server sync failed:', result.error || response.statusText);
      alert("Roster loaded locally, but server sync failed. Players page may not show data.");
    }
  } catch (error) {
    console.error('Failed to sync with server:', error);
    alert("Roster loaded locally, but server sync failed. Players page may not show data.");
  }
};

ui.btnSave.onclick = () => {
  // snapshot live totals for save
  const snap = JSON.parse(JSON.stringify(state));
  const n = nowSec();
  snap.players.forEach(p=>{
    if (p.onField && p.stintStart) {
      p.totalSec += (n - p.stintStart);
      // keep stintStart so live resume matches reality
    }
  });
  const blob = new Blob([JSON.stringify(snap,null,2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `sideline_${new Date().toISOString().replace(/[:.]/g,"-")}.json`;
  a.click();
};

ui.btnLoad.onclick = () => ui.fileLoad.click();
ui.fileLoad.onchange = async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const txt = await file.text();
  try {
    const obj = JSON.parse(txt);
    // basic shape validation
    if (!Array.isArray(obj.players)) throw new Error("Invalid file");
    state = obj;
    saveLocal();
    renderAll();
    alert("Game loaded.");
  } catch (err) {
    alert("Failed to load: "+err.message);
  } finally {
    e.target.value = "";
  }
};

ui.btnClear.onclick = () => {
  if (confirm("Clear roster and game state?")) resetAll();
};

ui.btnSetSchedule.onclick = () => {
  const t = ui.scheduledHHMM.value.trim();
  if (!t || !/^\d{1,2}:\d{2}$/.test(t)) { alert("Use HH:MM (24-hour)"); return; }
  const [hh,mm] = t.split(":").map(Number);
  const d = new Date();
  d.setHours(hh, mm, 0, 0);
  state.scheduledStartTs = Math.floor(d.getTime()/1000);
  saveLocal();
  renderSetup();
};

ui.btnStart.onclick = startGame;
ui.btnPause.onclick = pauseGame;
ui.btnHalftime.onclick = startHalftime;
ui.btnEndHalftime.onclick = endHalftime;
ui.btnApplyFormat.onclick = () => {
  const minutes = parseInt(ui.formatMinutes.value, 10);
  const periods = parseInt(ui.formatPeriods.value, 10);
  if (Number.isNaN(minutes) || Number.isNaN(periods)) { alert("Enter minutes and period count."); return; }
  if (minutes < 10 || minutes > 120) { alert("Minutes must be between 10 and 120."); return; }
  if (periods < 1 || periods > 4) { alert("Periods must be between 1 and 4."); return; }
  if (minutes * 60 < periods * 60) { alert("Provide at least one minute per period."); return; }
  if (state.gameStartTs) { alert("Stop/reset the game before changing the timer format."); return; }
  state.gameLengthSec = minutes * 60;
  state.periodCount = periods;
  ensurePeriodArrays();
  state.periodElapsed = Array(periods).fill(0);
  state.periodAdjust = Array(periods).fill(0);
  state.periodStoppage = Array(periods).fill(0);
  state.currentPeriodIndex = 0;
  state.periodStartTs = null;
  recalcAggregateAdjustment();
  saveLocal();
  renderAll();
};

ui.adjustKind.onchange = () => {
  const isStoppage = ui.adjustKind.value === "stoppage";
  ui.adjustAll.disabled = isStoppage;
  if (isStoppage) ui.adjustAll.checked = false;
};

ui.btnApplyManual.onclick = () => {
  ensurePeriodArrays();
  const kind = ui.adjustKind.value;
  const periodIndex = parseInt(ui.adjustPeriod.value, 10);
  const seconds = parseInt(ui.adjustSeconds.value, 10);
  if (Number.isNaN(periodIndex)) { alert("Select a period."); return; }
  if (Number.isNaN(seconds)) { alert("Enter seconds (integer)."); return; }
  if (kind === "adjustment") {
    if (seconds === 0) { alert("Enter a non-zero adjustment."); return; }
    if (ui.adjustAll.checked) {
      for (let i = 0; i < state.periodCount; i++) {
        state.periodAdjust[i] += seconds;
      }
    } else {
      state.periodAdjust[periodIndex] += seconds;
    }
    recalcAggregateAdjustment();
  } else {
    if (seconds <= 0) { alert("Stoppage time must be positive seconds."); return; }
    state.periodStoppage[periodIndex] = Math.max(0, state.periodStoppage[periodIndex] + seconds);
  }
  ui.adjustSeconds.value = "";
  saveLocal();
  renderAll();
};

/** -------------------------
 *  Lineup
 *  ------------------------- */
function renderLineup() {
  // slots
  ui.slotList.innerHTML = "";
  REQUIRED_SLOTS.forEach((pos, idx)=>{
    const li = document.createElement("li");
    li.style.padding="6px 8px";
    li.style.border="1px solid var(--line)";
    li.style.borderRadius="8px";
    li.style.marginBottom="6px";
    li.style.cursor="pointer";
    li.dataset.index = idx;
    li.innerHTML = `<b>${idx+1}. ${pos}</b> â€“ ${POS_FULL[pos]}`;
    li.onclick = () => { selectedSlotIndex = idx; highlightSlots(); };
    ui.slotList.appendChild(li);
  });
  highlightSlots();

  // roster table
  ui.rosterTable.innerHTML = "";
  
  // Get list of assigned players (excluding header)
  const assignedPlayers = new Set();
  Array.from(ui.assignTable.querySelectorAll("tbody tr td:nth-child(2)")).forEach(td => {
    assignedPlayers.add(td.textContent);
  });

  state.players.slice().sort((a,b)=> (a.number||"").localeCompare(b.number||"") || a.name.localeCompare(b.name))
    .forEach(p=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${p.name}</td><td>${p.number||""}</td><td>${(p.preferred||"").toUpperCase()}</td>`;
      
      // Check if player is already assigned
      if (assignedPlayers.has(p.name)) {
        tr.classList.add('player-used');
        tr.onclick = () => alert(`${p.name} is already assigned to a position.`);
      } else {
        tr.style.cursor="pointer";
        tr.onclick = ()=>assignSelectedSlot(p.name);
      }
      
      ui.rosterTable.appendChild(tr);
    });

  // Don't clear assignment table - let assignments persist
}

function highlightSlots() {
  // Get current assignments to check which slots are filled (excluding header)
  const assignedSlots = new Set();
  Array.from(ui.assignTable.querySelectorAll("tbody tr")).forEach(r=>{
    if (r.children.length >= 2) {
      const slotText = r.children[0].textContent; // "1. GK"
      const slotIndex = parseInt(slotText.split('.')[0]) - 1;
      assignedSlots.add(slotIndex);
    }
  });

  Array.from(ui.slotList.children).forEach((li,i)=>{
    // Remove classes first
    li.classList.remove('slot-filled');
    
    // Add filled class if slot is assigned (this preserves the visual cue)
    if (assignedSlots.has(i)) {
      li.classList.add('slot-filled');
    }
    
    // Set background for selected slot (this overrides filled background for selected slot)
    if (i === selectedSlotIndex) {
      li.style.background = "#0c1732";
    } else if (!assignedSlots.has(i)) {
      li.style.background = "transparent";
    }
  });
}

function updateRosterVisualCues() {
  // Get list of assigned players (excluding header)
  const assignedPlayers = new Set();
  Array.from(ui.assignTable.querySelectorAll("tbody tr td:nth-child(2)")).forEach(td => {
    assignedPlayers.add(td.textContent);
  });

  // Update existing roster table rows
  Array.from(ui.rosterTable.querySelectorAll("tr")).forEach(tr => {
    const playerName = tr.children[0].textContent;
    
    // Remove existing classes
    tr.classList.remove('player-used');
    
    // Check if player is assigned
    if (assignedPlayers.has(playerName)) {
      tr.classList.add('player-used');
      tr.onclick = () => alert(`${playerName} is already assigned to a position.`);
      tr.style.cursor = "not-allowed";
    } else {
      tr.style.cursor = "pointer";
      tr.onclick = () => assignSelectedSlot(playerName);
    }
  });
}

function assignSelectedSlot(playerName) {
  if (selectedSlotIndex===null) { alert("Select a slot on the left first."); return; }
  // prevent duplicate player (excluding header)
  const existing = Array.from(ui.assignTable.querySelectorAll("tbody tr td:nth-child(2)")).map(td=>td.textContent);
  if (existing.includes(playerName)) { alert("Player already assigned."); return; }

  // remove previous assignment on this slot (excluding header)
  const slotLabel = `${selectedSlotIndex+1}. ${REQUIRED_SLOTS[selectedSlotIndex]}`;
  const rows = Array.from(ui.assignTable.querySelectorAll("tbody tr"));
  for (const r of rows) {
    if (r.children[0].textContent === slotLabel) r.remove();
  }

  const tr = document.createElement("tr");
  tr.innerHTML = `<td>${slotLabel}</td><td>${playerName}</td>`;
  ui.assignTable.appendChild(tr);
  
  // Refresh visual cues after assignment (without clearing assignments)
  highlightSlots();
  
  // Update player visual cues by re-rendering just the roster table
  updateRosterVisualCues();
}

ui.btnClearAssign.onclick = () => { 
  ui.assignTable.innerHTML = ""; 
  highlightSlots(); // Refresh slot visual cues
  updateRosterVisualCues(); // Refresh player visual cues
};

ui.btnStartGame.onclick = async () => {
  try {
    // Disable button to prevent double-clicking
    ui.btnStartGame.disabled = true;
    ui.btnStartGame.textContent = 'Validating...';
    
    // Build assignments (excluding header)
    const assigned = {};
    const assignmentRows = Array.from(ui.assignTable.querySelectorAll("tbody tr"));
    
    if (assignmentRows.length === 0) {
      showError('No player assignments found. Please assign players to positions first.');
      return;
    }
    
    assignmentRows.forEach(row => {
      const slot = row.children[0].textContent; // "1. GK"
      const pos = slot.split(".")[1].trim().split(" ")[0];
      const name = row.children[1].textContent;
      
      if (!name || name.trim() === '') {
        throw new Error(`Position ${slot} is not assigned to any player`);
      }
      
      assigned[pos] = (assigned[pos] || []).concat([name]);
    });
    
    // Enhanced validation
    const need = {GK: 1, DF: 3, MF: 2, ST: 3};
    const got = {
      GK: (assigned.GK || []).length, 
      DF: (assigned.DF || []).length, 
      MF: (assigned.MF || []).length, 
      ST: (assigned.ST || []).length
    };
    
    // Check formation completeness
    const validationErrors = [];
    const warnings = [];
    
    for (const [position, required] of Object.entries(need)) {
      const actual = got[position];
      if (actual < required) {
        validationErrors.push(`Need ${required} ${position} player(s), only have ${actual}`);
      } else if (actual > required) {
        validationErrors.push(`Too many ${position} players: need ${required}, have ${actual}`);
      }
    }
    
    // Check for duplicate player assignments
    const allAssignedPlayers = [];
    for (const players of Object.values(assigned)) {
      allAssignedPlayers.push(...players);
    }
    
    const uniquePlayers = new Set(allAssignedPlayers);
    if (uniquePlayers.size !== allAssignedPlayers.length) {
      validationErrors.push('Same player assigned to multiple positions');
    }
    
    // Check if all assigned players exist in roster
    const availablePlayers = state.players.map(p => p.name);
    for (const playerName of allAssignedPlayers) {
      if (!availablePlayers.includes(playerName)) {
        validationErrors.push(`Player "${playerName}" not found in roster`);
      }
    }
    
    // Check position preferences and add warnings
    for (const [position, players] of Object.entries(assigned)) {
      for (const playerName of players) {
        const player = state.players.find(p => p.name === playerName);
        if (player && player.preferred) {
          const preferredPositions = player.preferred.split(',').map(p => p.trim().toUpperCase());
          if (!preferredPositions.includes(position)) {
            warnings.push(`${playerName} is playing ${position} but prefers ${player.preferred}`);
          }
        }
      }
    }
    
    // Show validation errors if any
    if (validationErrors.length > 0) {
      const errorMessage = 'Cannot start game - lineup validation failed:\n\n' + 
                          validationErrors.join('\n') + 
                          '\n\nPlease fix these issues and try again.';
      showError(errorMessage);
      return;
    }
    
    // Show warnings if any (but allow game to start)
    if (warnings.length > 0) {
      const warningMessage = 'Starting game with the following warnings:\n\n' + 
                            warnings.join('\n') + 
                            '\n\nDo you want to continue?';
      
      if (!confirm(warningMessage)) {
        return;
      }
    }
    
    ui.btnStartGame.textContent = 'Starting Game...';
    
    // Try API-based game start with formation validation
    try {
      const response = await fetch('/api/timer/start', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          formation_name: state.currentFormation || null
        })
      });
      
      const data = await response.json();
      
      if (!data.success) {
        // Show detailed API validation errors
        let errorMessage = data.error || 'Failed to start game';
        
        if (data.validation_errors && data.validation_errors.length > 0) {
          errorMessage += '\n\nValidation errors:\n' + data.validation_errors.join('\n');
        }
        
        if (data.suggestions && data.suggestions.length > 0) {
          errorMessage += '\n\nSuggestions:\n' + data.suggestions.join('\n');
        }
        
        showError(errorMessage);
        return;
      }
      
      // Show API warnings if any
      if (data.warnings && data.warnings.length > 0) {
        const apiWarnings = 'Game started with warnings:\n' + data.warnings.join('\n');
        console.warn(apiWarnings);
        // Could show a toast notification here instead of alert
      }
      
      // Success - apply the lineup and start the game
      await applyLineupAndStartGame(assigned);
      
    } catch (apiError) {
      console.warn('API game start failed, falling back to local:', apiError);
      
      // Fallback to local game start
      await applyLineupAndStartGame(assigned);
    }
    
  } catch (error) {
    console.error('Error starting game:', error);
    showError(`Failed to start game: ${error.message}`);
  } finally {
    // Re-enable button
    ui.btnStartGame.disabled = false;
    ui.btnStartGame.textContent = 'Start Game';
  }
};

// Helper function to show errors with better UX
function showError(message) {
  // Create a more user-friendly error display
  const errorDiv = document.createElement('div');
  errorDiv.style.cssText = `
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    background: var(--over); color: white; padding: 16px 24px;
    border-radius: 8px; z-index: 10000; max-width: 80%;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  `;
  errorDiv.innerHTML = `
    <strong>âš ï¸ Lineup Validation Error</strong><br>
    <div style="margin-top: 8px; white-space: pre-line;">${message}</div>
    <button onclick="this.parentElement.remove()" style="
      margin-top: 12px; background: rgba(255,255,255,0.2); 
      border: 1px solid rgba(255,255,255,0.3); color: white;
      padding: 4px 12px; border-radius: 4px; cursor: pointer;
    ">Close</button>
  `;
  
  document.body.appendChild(errorDiv);
  
  // Auto-remove after 10 seconds
  setTimeout(() => {
    if (errorDiv.parentElement) {
      errorDiv.remove();
    }
  }, 10000);
}

// Extracted function to apply lineup and start game
async function applyLineupAndStartGame(assigned) {
  // Reset and apply lineup
  const n = nowSec();
  state.players.forEach(p => { 
    p.onField = false; 
    p.position = null; 
    p.stintStart = null; 
  });
  
  for (const [pos, names] of Object.entries(assigned)) {
    for (const nm of names) {
      const p = state.players.find(x => x.name === nm);
      if (p) { 
        p.onField = true; 
        p.position = pos; 
        p.stintStart = n; 
      }
    }
  }
  
  const firstStart = !state.gameStartTs;
  if (firstStart) state.gameStartTs = n;
  
  ensurePeriodArrays();
  if (firstStart) {
    state.currentPeriodIndex = 0;
    state.periodElapsed = Array(state.periodCount).fill(0);
  }
  
  state.periodStartTs = n;
  state.breakActive = false;
  state.paused = false;
  
  saveLocal();
  show("game");
  renderGame();
  startTick();
  
  // Show success message
  const successDiv = document.createElement('div');
  successDiv.style.cssText = `
    position: fixed; top: 20px; right: 20px;
    background: var(--ok); color: white; padding: 12px 20px;
    border-radius: 8px; z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  `;
  successDiv.innerHTML = 'âœ… Game started successfully!';
  
  document.body.appendChild(successDiv);
  setTimeout(() => successDiv.remove(), 3000);
}

/** -------------------------
 *  Game
 *  ------------------------- */
function startGame() {
  // Clear any existing scheduled start to prevent infinite retries before attempting to start
  const wasScheduled = state.scheduledStartTs !== null;
  if (wasScheduled) {
    console.log('Clearing scheduled start time before attempting game start');
    state.scheduledStartTs = null;
    saveLocal();
  }
  
  // Try API first, fall back to local
  apiStartGame().catch((error) => {
    console.warn('API start game failed:', error);
    
    // If this was a scheduled start, show warning and don't fall back
    if (wasScheduled) {
      showNotification('Cannot start game automatically - check lineup and try manual start', 'warning');
      return; // Don't fall back to local implementation for scheduled starts
    }
    
    // Fallback to original local implementation (only for manual starts)
    ensurePeriodArrays();
    const n = nowSec();
    const firstStart = !state.gameStartTs;
    if (firstStart) {
      state.gameStartTs = n;
      state.currentPeriodIndex = 0;
      state.periodElapsed = Array(state.periodCount).fill(0);
    }
    if (!state.periodStartTs || state.paused || state.breakActive) {
      state.periodStartTs = n;
    }
    state.breakActive = false;
    state.paused = false;
    state.players.forEach(p=>{
      if (p.onField && !p.stintStart) p.stintStart = n;
    });
    saveLocal();
    renderGame();
    startTick();
  });
}

function pauseGame() {
  // Try API first, fall back to local
  apiPauseGame().catch(() => {
    // Fallback to original local implementation
    if (state.paused) return;
    const n = nowSec();
    ensurePeriodArrays();
    if (state.periodStartTs) {
      state.periodElapsed[state.currentPeriodIndex] += Math.max(0, n - state.periodStartTs);
      state.periodStartTs = null;
    }
    state.players.forEach(p=>{
      if (p.onField && p.stintStart) {
        p.totalSec += (n - p.stintStart);
        p.stintStart = null;
      }
    });
    state.paused = true;
    saveLocal();
    renderGame();
    stopTick();
  });
}

function startHalftime() {
  // Try API first, fall back to local
  apiStartHalftime().catch(() => {
    // Fallback to original local implementation
    pauseGame();
    state.breakActive = true;
    state.halftimeEndTs = nowSec() + Math.floor(HALFTIME_MIN*60);
    saveLocal();
    renderGame();
    startTick(); // to show countdown
  });
}

function endHalftime() {
  ensurePeriodArrays();
  state.breakActive = false;
  state.halftimeEndTs = null;
  if (state.currentPeriodIndex < state.periodCount - 1) {
    state.currentPeriodIndex += 1;
  }
  const n = nowSec();
  state.periodStartTs = n;
  state.paused = false;
  if (!state.gameStartTs) state.gameStartTs = n;
  state.players.forEach(p=>{
    if (p.onField && !p.stintStart) p.stintStart = n;
  });
  saveLocal();
  renderGame();
  startTick();
}

ui.gStart.onclick = startGame;
ui.gPause.onclick = pauseGame;
ui.gHalf.onclick = startHalftime;
ui.gSave.onclick = () => ui.btnSave.click();

function renderGame() {
  ensurePeriodArrays();
  const elapsed = gameElapsedSeconds();
  const target = state.gameLengthSec + totalStoppageSeconds();
  ui.clockLabel.textContent = `${fmtMMSS(elapsed)} / ${fmtMMSS(target)}`;
  ui.statusLabel.textContent = state.paused ? "PAUSED" : "RUNNING";

  const periodLabel = describePeriodLabel(state.currentPeriodIndex + 1, state.periodCount);
  ui.periodPill.textContent = `${periodLabel} (${state.currentPeriodIndex + 1}/${state.periodCount})`;
  ui.metaPill.textContent = `Stoppage ${fmtMMSS(totalStoppageSeconds())} â€¢ Adjust ${fmtSignedMMSS(totalAdjustmentSeconds())}`;

  if (state.breakActive) {
    if (state.halftimeEndTs && nowSec() <= state.halftimeEndTs) {
      const remain = Math.max(0, state.halftimeEndTs - nowSec());
      ui.halfLabel.style.display = "";
      ui.halfLabel.textContent = `BREAK ${fmtMMSS(remain)}`;
    } else {
      ui.halfLabel.style.display = "";
      ui.halfLabel.textContent = "BREAK";
    }
  } else {
    ui.halfLabel.style.display = "none";
  }

  if (state.scheduledStartTs && !state.gameStartTs) {
    const delta = state.scheduledStartTs - nowSec();
    if (delta > 0) {
      ui.schedLabel.style.display = "";
      ui.schedLabel.textContent = `Starts in ${fmtMMSS(delta)}`;
    } else {
      ui.schedLabel.style.display = "";
      ui.schedLabel.textContent = `Startingâ€¦`;
      // Prevent calling startGame multiple times rapidly
      if (!window._gameStartAttempted) {
        window._gameStartAttempted = true;
        
        // Before attempting scheduled start, verify prerequisites
        if (!state.roster || Object.keys(state.roster).length === 0) {
          console.warn('Scheduled start cancelled: No players in roster');
          ui.schedLabel.textContent = 'Cannot start: Add players first';
          ui.schedLabel.style.color = 'red';
          // Clear the scheduled start since prerequisites aren't met
          state.scheduledStartTs = null;
          saveLocal();
          window._gameStartAttempted = false;
          return;
        }
        
        startGame();
        // Reset flag after a reasonable delay
        setTimeout(() => { 
          window._gameStartAttempted = false;
        }, 2000);
      }
    }
  } else {
    ui.schedLabel.style.display = "none";
  }

  ui.periodTable.innerHTML = "";
  const now = nowSec();
  for (let i = 0; i < state.periodCount; i++) {
    const running = (i === state.currentPeriodIndex && state.periodStartTs && !state.paused && !state.breakActive)
      ? Math.max(0, now - state.periodStartTs)
      : 0;
    const elapsedReg = (state.periodElapsed[i] || 0) + running;
    const adjust = state.periodAdjust[i] || 0;
    const stoppage = state.periodStoppage[i] || 0;
    const remain = periodRemainingSeconds(i);
    const tr = document.createElement("tr");
    if (i === state.currentPeriodIndex && !state.breakActive) {
      tr.style.fontWeight = "600";
    }
    tr.innerHTML = `
      <td>${describePeriodLabel(i + 1, state.periodCount)}</td>
      <td>${fmtMMSS(periodRegulationSeconds(i))}</td>
      <td>${fmtMMSS(elapsedReg)}</td>
      <td>${fmtSignedMMSS(adjust)}</td>
      <td>${fmtMMSS(stoppage)}</td>
      <td>${fmtMMSS(remain)}</td>
    `;
    ui.periodTable.appendChild(tr);
  }

  // On-field table
  ui.onFieldTable.innerHTML = "";
  const order = {GK:0, DF:1, MF:2, ST:3};
  const on = state.players.filter(p=>p.onField).sort((a,b)=>
     (order[a.position||"Z"] - order[b.position||"Z"]) ||
     (a.number||"").localeCompare(b.number||"") ||
     a.name.localeCompare(b.name));

  on.forEach(p=>{
    const stint = currentStint(p);
    const total = totalLive(p);
    const tr = document.createElement("tr");
    tr.onclick = ()=>{ selectedOutName = p.name; highlightSelections(); };
    tr.style.cursor = 'pointer';
    // Add selection highlighting
    if (selectedOutName === p.name) {
      tr.className = 'selected-out';
    }
    tr.innerHTML = `
      <td>${p.position||"-"}</td>
      <td>${p.name}</td>
      <td>${p.number||""}</td>
      <td>${fmtMMSS(stint)}</td>
      <td><span class="fair ${fairnessClass(total)}">${fmtMMSS(total)}</span></td>
      <td>${(p.preferred||"").toUpperCase()}</td>`;
    ui.onFieldTable.appendChild(tr);
  });

  // Roster table
  ui.rosterGameTable.innerHTML = "";
  state.players.slice().sort((a,b)=> (a.onField===b.onField?0:a.onField?-1:1) || (a.number||"").localeCompare(b.number||"") || a.name.localeCompare(b.name))
    .forEach(p=>{
      const stint = currentStint(p);
      const total = totalLive(p);
      const tr = document.createElement("tr");
      tr.onclick = ()=>{ selectedInName = p.name; highlightSelections(); };
      tr.style.cursor = 'pointer';
      // Add selection highlighting
      if (selectedInName === p.name) {
        tr.className = 'selected-in';
      }
      tr.innerHTML = `
        <td>${p.name}</td>
        <td>${p.number||""}</td>
        <td>${p.onField?'<span class="pill status-in">IN</span>':'<span class="pill status-out">OUT</span>'}</td>
        <td>${p.position||"-"}</td>
        <td>${fmtMMSS(stint)}</td>
        <td><span class="fair ${fairnessClass(total)}">${fmtMMSS(total)}</span></td>
        <td>${(p.preferred||"").toUpperCase()}</td>`;
      ui.rosterGameTable.appendChild(tr);
    });

  // queue
  ui.queueList.innerHTML = "";
  subQueue.forEach((q, i)=>{
    const outPlayer = state.players.find(p => p.name === q.out);
    const inPlayer = state.players.find(p => p.name === q.in);
    const position = outPlayer?.position || '?';
    const outNum = outPlayer?.number || '';
    const inNum = inPlayer?.number || '';
    
    const div = document.createElement("div");
    div.className = "queue-item";
    div.innerHTML = `
      <div class="row" style="flex:1;align-items:center;">
        <span class="player-out">${q.out} #${outNum}</span>
        <span class="position-badge">${position}</span>
        <span class="sub-arrow">âžœ</span>
        <span class="player-in">${q.in} #${inNum}</span>
        ${inPlayer?.onField ? '<span class="pill" style="background:var(--warn);color:#1b1400;margin-left:8px;">Position Swap</span>' : ''}
      </div>
      <button class="btn" onclick="removeQueue(${i})">âœ• Remove</button>
    `;
    ui.queueList.appendChild(div);
  });

  renderReports();
}

function highlightSelections() {
  // Update selection status display
  const statusDiv = document.getElementById('selectionStatus');
  const outDisplay = document.getElementById('outPlayerDisplay');
  const inDisplay = document.getElementById('inPlayerDisplay');
  
  if (selectedOutName || selectedInName) {
    statusDiv.style.display = 'block';
    
    if (selectedOutName) {
      const outPlayer = state.players.find(p => p.name === selectedOutName);
      const outNum = outPlayer?.number || '';
      const outPos = outPlayer?.position || '?';
      outDisplay.innerHTML = `${selectedOutName} #${outNum} <span class="position-badge">${outPos}</span>`;
    } else {
      outDisplay.textContent = 'Click player in "On Field" table';
    }
    
    if (selectedInName) {
      const inPlayer = state.players.find(p => p.name === selectedInName);
      const inNum = inPlayer?.number || '';
      const inStatus = inPlayer?.onField ? ' (currently on field - will swap positions)' : '';
      inDisplay.innerHTML = `${selectedInName} #${inNum}${inStatus}`;
    } else {
      inDisplay.textContent = 'Click player in "Roster" table';
    }
  } else {
    statusDiv.style.display = 'none';
  }
  
  // Re-render game to update table highlighting
  renderGame();
}

ui.btnQueue.onclick = () => {
  if (!selectedOutName) { 
    alert("âš ï¸ Please select a player from the 'On Field' table to substitute OUT."); 
    return; 
  }
  if (!selectedInName) { 
    alert("âš ï¸ Please select a player from the 'Roster' table to substitute IN."); 
    return; 
  }
  if (selectedOutName === selectedInName) { 
    alert("âš ï¸ Cannot substitute a player for themselves. Please select different players."); 
    return; 
  }

  // Label includes target slot (out player's position)
  const outP = state.players.find(p=>p.name===selectedOutName);
  const inP = state.players.find(p=>p.name===selectedInName);
  const label = inP.name + (inP.onField ? ` (swap to ${outP.position})` : "");
  subQueue.push({out: selectedOutName, in: selectedInName, _label: label});
  
  // Clear selections after adding to queue
  selectedOutName = null; 
  selectedInName = null;
  highlightSelections();
};

ui.btnClearQueue.onclick = () => { subQueue = []; renderGame(); };

function removeQueue(i) { subQueue.splice(i,1); renderGame(); }
window.removeQueue = removeQueue; // expose for onclick

ui.btnCommit.onclick = () => {
  if (!subQueue.length) { alert("No subs queued."); return; }
  const n = nowSec();
  subQueue.forEach(q=>{
    const pOut = state.players.find(p=>p.name===q.out);
    const pIn  = state.players.find(p=>p.name===q.in);
    if (!pOut || !pIn || !pOut.onField || !pOut.position) return;

    // if IN is on field â†’ position swap (both stay on field, just swap positions)
    if (pIn.onField) {
      // Save both positions
      const outPos = pOut.position;
      const inPos = pIn.position;
      
      // Swap positions - both players stay on field
      pOut.position = inPos;
      pIn.position = outPos;
    } else {
      // Regular substitution: OUT comes off, IN goes on
      // Save the position before clearing it
      const positionToFill = pOut.position;

      // end OUT stint
      if (pOut.stintStart) { pOut.totalSec += (n - pOut.stintStart); }
      pOut.onField = false; pOut.position = null; pOut.stintStart = null;

      // Start IN stint
      pIn.onField = true; pIn.position = positionToFill; pIn.stintStart = n;
    }
  });
  subQueue = [];
  saveLocal();
  renderGame();
};

function startTick() {
  if (tickHandle) return;
  tickHandle = setInterval(()=>{
    // halftime countdown end
    if (state.halftimeEndTs && nowSec() >= state.halftimeEndTs) {
      state.halftimeEndTs = null;
      state.breakActive = false;
      saveLocal();
      alert("Halftime complete. Press Start/Resume to continue.");
    }
    renderGame();
    renderReports();
  }, 1000);
}
function stopTick(){ if (tickHandle) { clearInterval(tickHandle); tickHandle = null; } }

function renderReports() {
  if (!ui.reportSummary) return;
  const snapshot = buildReportSnapshot();

  if (!snapshot) {
    ui.reportSummary.textContent = "Add players to view analytics.";
    ui.reportDetail.textContent = "";
    ui.reportDistribution.textContent = "";
    ui.reportTargets.textContent = "";
    ui.reportElapsed.textContent = "";
    ui.reportTable.innerHTML = "";
    return;
  }

  const elapsedRounded = Math.round(snapshot.elapsed);
  const totalTargetRounded = Math.round(snapshot.totalTarget);
  const regulationRounded = Math.round(snapshot.regulationSeconds);
  const stoppageRounded = Math.round(snapshot.stoppage);
  const adjustmentsRounded = Math.round(snapshot.adjustments);
  const remaining = Math.max(0, totalTargetRounded - elapsedRounded);

  ui.reportSummary.textContent = `Elapsed ${fmtMMSS(elapsedRounded)} / Target ${fmtMMSS(totalTargetRounded)} â€” ${snapshot.rosterSize} players`;
  ui.reportDetail.textContent = `Regulation ${fmtMMSS(regulationRounded)} â€¢ Stoppage ${fmtMMSS(stoppageRounded)} â€¢ Adjust ${fmtSignedMMSS(adjustmentsRounded)}`;
  ui.reportTargets.textContent = `Per player target ${fmtMMSS(snapshot.perPlayerRounded)}`;
  ui.reportElapsed.textContent = `Remaining ${fmtMMSS(remaining)}`;

  const fairness = snapshot.fairnessCounts || { under: 0, ok: 0, over: 0 };
  const fairnessParts = [
    `${fairness.under || 0} under`,
    `${fairness.ok || 0} on target`,
    `${fairness.over || 0} over`,
  ];
  ui.reportDistribution.textContent = `Average ${fmtMMSS(Math.round(snapshot.average))} â€¢ Median ${fmtMMSS(Math.round(snapshot.median))} â€¢ Range ${fmtMMSS(Math.round(snapshot.min))}â€“${fmtMMSS(Math.round(snapshot.max))} â€¢ Fairness ${fairnessParts.join(" / ")}`;

  ui.reportTable.innerHTML = "";
  snapshot.rows.forEach((row) => {
    const tr = document.createElement("tr");
    const preferred = row.preferredDisplay || "â€”";
    const shareText = `${row.targetSharePercent.toFixed(1)}%`;
    tr.innerHTML = `
      <td>${row.name}</td>
      <td>${row.number}</td>
      <td>${preferred}</td>
      <td>${row.status}</td>
      <td><span class="fair ${row.fairness}">${fmtMMSS(Math.round(row.cumulativeSeconds))}</span></td>
      <td>${fmtMMSS(snapshot.perPlayerRounded)}</td>
      <td><span class="fair ${row.fairness}">${fmtSignedMMSS(Math.round(row.deltaSeconds))}</span></td>
      <td>${shareText}</td>
    `;
    ui.reportTable.appendChild(tr);
  });
}

/** -------------------------
 *  Setup view secondary render
 *  ------------------------- */
function renderSetup() {
  if (state.scheduledStartTs) {
    const d = new Date(state.scheduledStartTs*1000);
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    ui.scheduledLabel.textContent = `Scheduled for ${hh}:${mm}`;
  } else {
    ui.scheduledLabel.textContent = "";
  }
  ui.formatMinutes.value = Math.round(state.gameLengthSec/60);
  ui.formatPeriods.value = String(state.periodCount);
  updatePeriodOptions();
}

function updatePeriodOptions() {
  ensurePeriodArrays();
  ui.adjustPeriod.innerHTML = "";
  for (let i = 0; i < state.periodCount; i++) {
    const option = document.createElement("option");
    option.value = String(i);
    option.textContent = describePeriodLabel(i + 1, state.periodCount);
    ui.adjustPeriod.appendChild(option);
  }
  if (state.periodCount > 0 && !ui.adjustPeriod.value) {
    ui.adjustPeriod.value = "0";
  }
  if (typeof ui.adjustKind.onchange === "function") {
    ui.adjustKind.onchange();
  }
}

/** -------------------------
 *  Players View Functions
 *  ------------------------- */

let selectedPlayer = null;

// Render the players table
function renderPlayers() {
  if (!ui.playersTable) return;
  
  fetch('/api/players')
    .then(response => response.json())
    .then(data => {
      ui.playersTable.innerHTML = '';
      
      // Check if the API call was successful and extract the players array
      if (data.success && Array.isArray(data.players)) {
        data.players.forEach(player => {
          const row = ui.playersTable.insertRow();
          row.onclick = () => selectPlayer(player);
          
          // Calculate age if date_of_birth is available
          let age = 'N/A';
          if (player.date_of_birth) {
            const birthDate = new Date(player.date_of_birth);
            const today = new Date();
            age = Math.floor((today - birthDate) / (365.25 * 24 * 60 * 60 * 1000));
          }
          
          // Get preferred positions
          const positions = player.preferred || 'N/A';
          
          // Get games played from statistics
          const gamesPlayed = player.statistics ? player.statistics.games_played : 0;
          
          row.innerHTML = `
            <td>${player.name}</td>
            <td>${player.number || 'N/A'}</td>
            <td>${age}</td>
            <td>${positions}</td>
            <td>${gamesPlayed}</td>
            <td>
              <button onclick="event.stopPropagation(); editPlayerInline('${player.name}')">Edit</button>
              <button onclick="event.stopPropagation(); deletePlayerInline('${player.name}')">Delete</button>
            </td>
          `;
        });
      } else {
        // Handle case where API call failed or returned invalid data
        console.warn('No players data received or API call failed:', data);
        ui.playersTable.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #666;">No players found</td></tr>';
      }
    })
    .catch(error => {
      console.error('Error loading players:', error);
      alert('Error loading players: ' + error.message);
    });
}

// Select a player and show details
function selectPlayer(player) {
  selectedPlayer = player;
  if (ui.playerDetails) {
    ui.playerDetails.innerHTML = `
      <h3>${player.name}</h3>
      <p><strong>Position:</strong> ${player.position}</p>
      <p><strong>Skill Level:</strong> ${player.skill_level}</p>
      ${player.contact_info ? `
        <h4>Contact Information</h4>
        <p><strong>Phone:</strong> ${player.contact_info.phone || 'N/A'}</p>
        <p><strong>Email:</strong> ${player.contact_info.email || 'N/A'}</p>
        <p><strong>Emergency Contact:</strong> ${player.contact_info.emergency_contact || 'N/A'}</p>
        <p><strong>Emergency Phone:</strong> ${player.contact_info.emergency_phone || 'N/A'}</p>
      ` : ''}
      ${player.medical_info ? `
        <h4>Medical Information</h4>
        <p><strong>Allergies:</strong> ${player.medical_info.allergies ? player.medical_info.allergies.join(', ') : 'None'}</p>
        <p><strong>Medications:</strong> ${player.medical_info.medications ? player.medical_info.medications.join(', ') : 'None'}</p>
        <p><strong>Medical Notes:</strong> ${player.medical_info.medical_notes || 'None'}</p>
      ` : ''}
      ${player.stats ? `
        <h4>Statistics</h4>
        <p><strong>Goals:</strong> ${player.stats.goals}</p>
        <p><strong>Assists:</strong> ${player.stats.assists}</p>
        <p><strong>Yellow Cards:</strong> ${player.stats.yellow_cards}</p>
        <p><strong>Red Cards:</strong> ${player.stats.red_cards}</p>
        <p><strong>Games Played:</strong> ${player.stats.games_played}</p>
        <p><strong>Total Minutes:</strong> ${player.stats.total_minutes}</p>
      ` : ''}
    `;
  }
  
  // Enable/disable action buttons based on selection
  if (ui.btnEditPlayer) ui.btnEditPlayer.disabled = false;
  if (ui.btnDeletePlayer) ui.btnDeletePlayer.disabled = false;
  if (ui.btnPlayerStats) ui.btnPlayerStats.disabled = false;
  if (ui.btnAttendance) ui.btnAttendance.disabled = false;
}

// Add new player
function addPlayer() {
  const name = prompt('Enter player name:');
  if (!name) return;
  
  const position = prompt('Enter position (forward, midfielder, defender, goalkeeper):', 'midfielder');
  if (!position) return;
  
  const skillLevel = prompt('Enter skill level (1-10):', '5');
  if (!skillLevel) return;
  
  const playerData = {
    name: name,
    position: position,
    skill_level: parseInt(skillLevel)
  };
  
  fetch('/api/players', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(playerData)
  })
    .then(response => response.json())
    .then(() => {
      renderPlayers();
      alert('Player added successfully!');
    })
    .catch(error => {
      console.error('Error adding player:', error);
      alert('Error adding player: ' + error.message);
    });
}

// Edit selected player
function editPlayer() {
  if (!selectedPlayer) {
    alert('Please select a player first.');
    return;
  }
  
  const name = prompt('Edit player name:', selectedPlayer.name);
  if (name === null) return;
  
  const position = prompt('Edit position:', selectedPlayer.position);
  if (position === null) return;
  
  const skillLevel = prompt('Edit skill level (1-10):', selectedPlayer.skill_level.toString());
  if (skillLevel === null) return;
  
  const playerData = {
    name: name,
    position: position,
    skill_level: parseInt(skillLevel)
  };
  
  fetch(`/api/players/${selectedPlayer.name}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(playerData)
  })
    .then(response => response.json())
    .then(() => {
      renderPlayers();
      selectedPlayer = null;
      ui.playerDetails.innerHTML = '';
      alert('Player updated successfully!');
    })
    .catch(error => {
      console.error('Error updating player:', error);
      alert('Error updating player: ' + error.message);
    });
}

// Delete selected player
function deletePlayer() {
  if (!selectedPlayer) {
    alert('Please select a player first.');
    return;
  }
  
  if (!confirm(`Are you sure you want to delete player ${selectedPlayer.name}?`)) {
    return;
  }
  
  fetch(`/api/players/${selectedPlayer.name}`, {
    method: 'DELETE'
  })
    .then(() => {
      renderPlayers();
      selectedPlayer = null;
      ui.playerDetails.innerHTML = '';
      alert('Player deleted successfully!');
    })
    .catch(error => {
      console.error('Error deleting player:', error);
      alert('Error deleting player: ' + error.message);
    });
}

// Inline edit player from table row
function editPlayerInline(playerName) {
  // Find the player in the current data
  fetch('/api/players')
    .then(response => response.json())
    .then(data => {
      const player = data.players.find(p => p.name === playerName);
      if (!player) {
        alert('Player not found');
        return;
      }
      
      const newNumber = prompt('Edit player number:', player.number || '');
      if (newNumber === null) return; // User cancelled
      
      const newPreferred = prompt('Edit preferred position(s):', player.preferred || '');
      if (newPreferred === null) return; // User cancelled
      
      // Update via API
      fetch(`/api/players/${playerName}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          number: newNumber,
          preferred: newPreferred
        })
      })
        .then(response => response.json())
        .then(() => {
          renderPlayers();
          alert('Player updated successfully!');
        })
        .catch(error => {
          console.error('Error updating player:', error);
          alert('Error updating player: ' + error.message);
        });
    })
    .catch(error => {
      console.error('Error fetching player:', error);
      alert('Error fetching player: ' + error.message);
    });
}

// Inline delete player from table row
function deletePlayerInline(playerName) {
  if (!confirm(`Are you sure you want to delete player ${playerName}?`)) {
    return;
  }
  
  fetch(`/api/players/${playerName}`, {
    method: 'DELETE'
  })
    .then(() => {
      renderPlayers();
      alert('Player deleted successfully!');
    })
    .catch(error => {
      console.error('Error deleting player:', error);
      alert('Error deleting player: ' + error.message);
    });
}

// Import players from CSV
function importPlayers() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.csv';
  input.onchange = function(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const formData = new FormData();
    formData.append('file', file);
    
    fetch('/api/players/import', {
      method: 'POST',
      body: formData
    })
      .then(response => response.json())
      .then(result => {
        renderPlayers();
        alert(`Import completed! Added ${result.added} players, updated ${result.updated} players.`);
      })
      .catch(error => {
        console.error('Error importing players:', error);
        alert('Error importing players: ' + error.message);
      });
  };
  input.click();
}

// Export players to CSV
function exportPlayers() {
  fetch('/api/players/export')
    .then(response => response.blob())
    .then(blob => {
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'players.csv';
      a.click();
      window.URL.revokeObjectURL(url);
    })
    .catch(error => {
      console.error('Error exporting players:', error);
      alert('Error exporting players: ' + error.message);
    });
}

// Show player statistics
function showPlayerStats() {
  if (!selectedPlayer) {
    alert('Please select a player first.');
    return;
  }
  
  fetch(`/api/players/${selectedPlayer.name}/stats`)
    .then(response => response.json())
    .then(stats => {
      const statsWindow = window.open('', '_blank', 'width=600,height=400');
      statsWindow.document.write(`
        <html>
        <head><title>${selectedPlayer.name} - Statistics</title></head>
        <body>
          <h2>${selectedPlayer.name} - Statistics</h2>
          <table border="1" cellpadding="5">
            <tr><td><strong>Goals:</strong></td><td>${stats.goals}</td></tr>
            <tr><td><strong>Assists:</strong></td><td>${stats.assists}</td></tr>
            <tr><td><strong>Yellow Cards:</strong></td><td>${stats.yellow_cards}</td></tr>
            <tr><td><strong>Red Cards:</strong></td><td>${stats.red_cards}</td></tr>
            <tr><td><strong>Games Played:</strong></td><td>${stats.games_played}</td></tr>
            <tr><td><strong>Total Minutes:</strong></td><td>${stats.total_minutes}</td></tr>
            <tr><td><strong>Average Minutes/Game:</strong></td><td>${stats.games_played > 0 ? Math.round(stats.total_minutes / stats.games_played) : 0}</td></tr>
          </table>
          <button onclick="window.close()">Close</button>
        </body>
        </html>
      `);
    })
    .catch(error => {
      console.error('Error loading player stats:', error);
      alert('Error loading player stats: ' + error.message);
    });
}

// Show attendance tracking
function showAttendance() {
  if (!selectedPlayer) {
    alert('Please select a player first.');
    return;
  }
  
  fetch(`/api/players/${selectedPlayer.name}/attendance`)
    .then(response => response.json())
    .then(attendance => {
      const attendanceWindow = window.open('', '_blank', 'width=600,height=400');
      const attendanceRows = attendance.map(record => 
        `<tr>
          <td>${record.date}</td>
          <td>${record.present ? 'Present' : 'Absent'}</td>
          <td>${record.minutes_played || 0}</td>
          <td>${record.notes || ''}</td>
        </tr>`
      ).join('');
      
      attendanceWindow.document.write(`
        <html>
        <head><title>${selectedPlayer.name} - Attendance</title></head>
        <body>
          <h2>${selectedPlayer.name} - Attendance</h2>
          <table border="1" cellpadding="5">
            <thead>
              <tr>
                <th>Date</th>
                <th>Status</th>
                <th>Minutes Played</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              ${attendanceRows}
            </tbody>
          </table>
          <button onclick="window.close()">Close</button>
        </body>
        </html>
      `);
    })
    .catch(error => {
      console.error('Error loading attendance:', error);
      alert('Error loading attendance: ' + error.message);
    });
}

/** -------------------------
 *  Formations
 *  ------------------------- */

let currentFormation = null;

async function renderFormations() {
  try {
    // Load formations
    const response = await fetch('/api/formations');
    const data = await response.json();
    
    if (data.success) {
      const select = ui.formationSelect;
      select.innerHTML = '<option value="">-- Select Formation --</option>';
      
      data.formations.forEach(formation => {
        const option = document.createElement('option');
        option.value = formation.name;
        option.textContent = formation.name;
        select.appendChild(option);
      });
    }
  } catch (error) {
    console.error('Failed to load formations:', error);
  }
  
  // Initialize field
  drawFieldMarkings();
}

function drawFieldMarkings() {
  const markings = ui.fieldMarkings;
  markings.innerHTML = `
    <!-- Center line -->
    <div style="position:absolute; left:50%; top:10px; bottom:10px; width:2px; background:white; transform:translateX(-50%);"></div>
    <!-- Center circle -->
    <div style="position:absolute; left:50%; top:50%; width:60px; height:60px; border:2px solid white; border-radius:50%; transform:translate(-50%, -50%);"></div>
    <!-- Goals -->
    <div style="position:absolute; left:10px; top:45%; width:20px; height:10%; background:transparent; border:2px solid white; border-left:none;"></div>
    <div style="position:absolute; right:10px; top:45%; width:20px; height:10%; background:transparent; border:2px solid white; border-right:none;"></div>
  `;
}

async function onFormationSelect() {
  const selectedName = ui.formationSelect.value;
  if (!selectedName) {
    clearFormationDisplay();
    return;
  }
  
  try {
    const response = await fetch(`/api/formations/${encodeURIComponent(selectedName)}`);
    const data = await response.json();
    
    if (data.success) {
      currentFormation = data.formation;
      displayFormation(currentFormation);
    }
  } catch (error) {
    console.error('Failed to load formation:', error);
  }
}

function displayFormation(formation) {
  // Update form fields
  ui.formationName.value = formation.name || '';
  ui.formationType.value = formation.formation_type || '4-4-2';
  ui.formationDescription.value = formation.description || '';
  
  // Draw positions on field
  drawFormationPositions(formation);
  
  // Update info
  const shape = getFormationShape(formation);
  const shapeText = shape.total >= 11 ? 
    `${shape.def}-${shape.mid}-${shape.for}` : 
    `Incomplete (${shape.total}/11)`;
  ui.formationInfo.textContent = `${formation.name}: ${shapeText}`;
  
  // Render position assignments
  renderPositionAssignments(formation);
}

function drawFormationPositions(formation) {
  const container = ui.formationPositions;
  container.innerHTML = '';
  
  if (!formation.positions) return;
  
  formation.positions.forEach((position, index) => {
    const dot = document.createElement('div');
    const x = (position.x / 100) * (container.offsetWidth - 20) + 10;
    const y = (position.y / 100) * (container.offsetHeight - 20) + 10;
    
    dot.style.cssText = `
      position: absolute;
      left: ${x}px;
      top: ${y}px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: ${getPositionColor(position.position_code)};
      border: 2px solid black;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      font-weight: bold;
      color: white;
      transform: translate(-50%, -50%);
    `;
    
    if (position.player_name) {
      dot.textContent = position.player_number || position.player_name.slice(0, 2);
      dot.title = position.player_name;
    } else {
      dot.textContent = position.position_code?.slice(0, 2) || 'P';
      dot.title = position.position_code || 'Position';
    }
    
    container.appendChild(dot);
  });
}

function getPositionColor(positionCode) {
  if (!positionCode) return 'gray';
  const code = positionCode.toUpperCase();
  
  if (code.includes('GK') || code.includes('GOALKEEPER')) return 'green';
  if (code.includes('DEF') || code.includes('DEFENDER') || code.includes('CB') || code.includes('LB') || code.includes('RB')) return 'blue';
  if (code.includes('MID') || code.includes('MIDFIELDER') || code.includes('CM') || code.includes('CDM') || code.includes('CAM')) return 'yellow';
  if (code.includes('FOR') || code.includes('FORWARD') || code.includes('ST') || code.includes('LW') || code.includes('RW')) return 'red';
  
  return 'gray';
}

function getFormationShape(formation) {
  if (!formation.positions) return { total: 0, gk: 0, def: 0, mid: 0, for: 0 };
  
  let gk = 0, def = 0, mid = 0, forward = 0;
  
  formation.positions.forEach(pos => {
    if (!pos.position_code) return;
    const code = pos.position_code.toUpperCase();
    
    if (code.includes('GK') || code.includes('GOALKEEPER')) gk++;
    else if (code.includes('DEF') || code.includes('DEFENDER') || code.includes('CB') || code.includes('LB') || code.includes('RB')) def++;
    else if (code.includes('MID') || code.includes('MIDFIELDER') || code.includes('CM') || code.includes('CDM') || code.includes('CAM')) mid++;
    else if (code.includes('FOR') || code.includes('FORWARD') || code.includes('ST') || code.includes('LW') || code.includes('RW')) forward++;
  });
  
  return { total: gk + def + mid + forward, gk, def, mid, for: forward };
}

function renderPositionAssignments(formation) {
  const container = ui.positionAssignments;
  container.innerHTML = '';
  
  if (!formation.positions) {
    container.innerHTML = '<div class="hint">No positions defined</div>';
    return;
  }
  
  formation.positions.forEach((position, index) => {
    const row = document.createElement('div');
    row.className = 'row';
    row.style.marginBottom = '8px';
    
    const label = document.createElement('div');
    label.style.minWidth = '60px';
    label.textContent = `${index + 1}. ${position.position_code || 'POS'}`;
    
    const select = document.createElement('select');
    select.style.flex = '1';
    select.innerHTML = '<option value="">-- Unassigned --</option>';
    
    // Add players to select
    state.roster.forEach(player => {
      const option = document.createElement('option');
      option.value = player.name;
      option.textContent = `${player.name} (${player.number || 'N/A'})`;
      if (position.player_name === player.name) {
        option.selected = true;
      }
      select.appendChild(option);
    });
    
    select.onchange = () => updatePlayerAssignment(index, select.value);
    
    row.appendChild(label);
    row.appendChild(select);
    container.appendChild(row);
  });
}

async function updatePlayerAssignment(positionIndex, playerName) {
  if (!currentFormation) return;
  
  try {
    const assignments = {};
    assignments[positionIndex] = playerName;
    
    const response = await fetch(`/api/formations/${encodeURIComponent(currentFormation.name)}/assign`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ assignments })
    });
    
    const data = await response.json();
    if (data.success) {
      currentFormation = data.formation;
      drawFormationPositions(currentFormation);
    }
  } catch (error) {
    console.error('Failed to update assignment:', error);
  }
}

async function createNewFormation() {
  const name = prompt('Formation name:');
  if (!name) return;
  
  const type = ui.formationType.value || '4-4-2';
  const description = prompt('Description (optional):') || '';
  
  try {
    // Create basic positions for the formation type
    const positions = generateFormationPositions(type);
    
    const response = await fetch('/api/formations', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        name,
        formation_type: type,
        description,
        positions
      })
    });
    
    const data = await response.json();
    if (data.success) {
      await renderFormations();
      ui.formationSelect.value = name;
      await onFormationSelect();
      alert('Formation created successfully!');
    } else {
      alert('Error: ' + data.error);
    }
  } catch (error) {
    console.error('Failed to create formation:', error);
    alert('Failed to create formation');
  }
}

function generateFormationPositions(type) {
  const positions = [];
  
  // Always start with goalkeeper
  positions.push({ x: 50, y: 5, position_code: 'GOALKEEPER' });
  
  switch (type) {
    case '4-4-2':
      // Defenders
      positions.push({ x: 20, y: 25, position_code: 'LEFT_BACK' });
      positions.push({ x: 35, y: 20, position_code: 'CENTER_BACK' });
      positions.push({ x: 65, y: 20, position_code: 'CENTER_BACK' });
      positions.push({ x: 80, y: 25, position_code: 'RIGHT_BACK' });
      // Midfielders
      positions.push({ x: 20, y: 55, position_code: 'LEFT_MIDFIELDER' });
      positions.push({ x: 40, y: 50, position_code: 'CENTRAL_MIDFIELDER' });
      positions.push({ x: 60, y: 50, position_code: 'CENTRAL_MIDFIELDER' });
      positions.push({ x: 80, y: 55, position_code: 'RIGHT_MIDFIELDER' });
      // Forwards
      positions.push({ x: 40, y: 80, position_code: 'STRIKER' });
      positions.push({ x: 60, y: 80, position_code: 'STRIKER' });
      break;
      
    case '4-3-3':
      // Defenders
      positions.push({ x: 20, y: 25, position_code: 'LEFT_BACK' });
      positions.push({ x: 35, y: 20, position_code: 'CENTER_BACK' });
      positions.push({ x: 65, y: 20, position_code: 'CENTER_BACK' });
      positions.push({ x: 80, y: 25, position_code: 'RIGHT_BACK' });
      // Midfielders
      positions.push({ x: 30, y: 50, position_code: 'CENTRAL_MIDFIELDER' });
      positions.push({ x: 50, y: 45, position_code: 'CENTRAL_MIDFIELDER' });
      positions.push({ x: 70, y: 50, position_code: 'CENTRAL_MIDFIELDER' });
      // Forwards
      positions.push({ x: 25, y: 80, position_code: 'LEFT_WINGER' });
      positions.push({ x: 50, y: 85, position_code: 'STRIKER' });
      positions.push({ x: 75, y: 80, position_code: 'RIGHT_WINGER' });
      break;
      
    default:
      // Default to 4-4-2 positions
      for (let i = 1; i < 11; i++) {
        positions.push({ x: (i % 3) * 30 + 25, y: Math.floor(i / 3) * 20 + 30, position_code: 'MIDFIELDER' });
      }
  }
  
  return positions;
}

async function createFromTemplate() {
  try {
    const response = await fetch('/api/formations/templates');
    const data = await response.json();
    
    if (data.success && data.templates.length > 0) {
      const list = ui.templateList;
      list.innerHTML = '';
      
      data.templates.forEach((template, index) => {
        const div = document.createElement('div');
        div.className = 'panel';
        div.style.cssText = 'margin-bottom: 8px; cursor: pointer; border: 2px solid transparent;';
        div.innerHTML = `
          <strong>${template.name}</strong><br>
          <span class="hint">${template.description || 'No description'}</span>
        `;
        
        div.onclick = () => {
          // Clear previous selection
          list.querySelectorAll('.panel').forEach(p => p.style.borderColor = 'transparent');
          div.style.borderColor = 'var(--accent)';
          list.selectedTemplate = template;
        };
        
        list.appendChild(div);
      });
      
      ui.templateModal.classList.remove('hidden');
    } else {
      alert('No formation templates available');
    }
  } catch (error) {
    console.error('Failed to load templates:', error);
    alert('Failed to load templates');
  }
}

async function createFormationFromTemplate() {
  const selectedTemplate = ui.templateList.selectedTemplate;
  const name = ui.templateFormationName.value.trim();
  
  if (!selectedTemplate) {
    alert('Please select a template');
    return;
  }
  
  if (!name) {
    alert('Please enter a formation name');
    return;
  }
  
  try {
    const response = await fetch('/api/formations/from-template', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        template_type: selectedTemplate.formation_type,
        name
      })
    });
    
    const data = await response.json();
    if (data.success) {
      ui.templateModal.classList.add('hidden');
      ui.templateFormationName.value = '';
      await renderFormations();
      ui.formationSelect.value = name;
      await onFormationSelect();
      alert('Formation created from template!');
    } else {
      alert('Error: ' + data.error);
    }
  } catch (error) {
    console.error('Failed to create from template:', error);
    alert('Failed to create formation from template');
  }
}

async function deleteFormation() {
  if (!currentFormation) {
    alert('No formation selected');
    return;
  }
  
  if (!confirm(`Delete formation "${currentFormation.name}"?`)) {
    return;
  }
  
  try {
    const response = await fetch(`/api/formations/${encodeURIComponent(currentFormation.name)}`, {
      method: 'DELETE'
    });
    
    const data = await response.json();
    if (data.success) {
      currentFormation = null;
      clearFormationDisplay();
      await renderFormations();
      alert('Formation deleted');
    } else {
      alert('Error: ' + data.error);
    }
  } catch (error) {
    console.error('Failed to delete formation:', error);
    alert('Failed to delete formation');
  }
}

async function saveFormation() {
  if (!currentFormation) {
    alert('No formation selected');
    return;
  }
  
  // Update formation with current form values
  currentFormation.name = ui.formationName.value.trim();
  currentFormation.formation_type = ui.formationType.value;
  currentFormation.description = ui.formationDescription.value.trim();
  
  if (!currentFormation.name) {
    alert('Formation name is required');
    return;
  }
  
  try {
    // For now, we'll just save the changes (the formation is already updated in memory)
    alert('Formation saved! (Note: Full save functionality requires backend implementation)');
  } catch (error) {
    console.error('Failed to save formation:', error);
    alert('Failed to save formation');
  }
}

async function autoAssignPlayers() {
  if (!currentFormation) {
    alert('No formation selected');
    return;
  }
  
  try {
    const assignments = {};
    const availablePlayers = [...state.roster];
    
    currentFormation.positions.forEach((position, index) => {
      if (availablePlayers.length > 0) {
        const player = availablePlayers.shift();
        assignments[index] = player.name;
      }
    });
    
    const response = await fetch(`/api/formations/${encodeURIComponent(currentFormation.name)}/assign`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ assignments })
    });
    
    const data = await response.json();
    if (data.success) {
      currentFormation = data.formation;
      displayFormation(currentFormation);
      alert('Players auto-assigned!');
    }
  } catch (error) {
    console.error('Failed to auto-assign:', error);
    alert('Failed to auto-assign players');
  }
}

async function clearAssignments() {
  if (!currentFormation) {
    alert('No formation selected');
    return;
  }
  
  try {
    const response = await fetch(`/api/formations/${encodeURIComponent(currentFormation.name)}/assign`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ assignments: {} })
    });
    
    const data = await response.json();
    if (data.success) {
      currentFormation = data.formation;
      displayFormation(currentFormation);
      alert('All assignments cleared!');
    }
  } catch (error) {
    console.error('Failed to clear assignments:', error);
    alert('Failed to clear assignments');
  }
}

async function suggestFormation() {
  try {
    const response = await fetch('/api/formations/suggest', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({})
    });
    
    const data = await response.json();
    if (data.success) {
      currentFormation = data.formation;
      displayFormation(currentFormation);
      alert(`Suggested formation: ${data.formation.name}\nBased on your current roster.`);
    } else {
      alert('Error: ' + data.error);
    }
  } catch (error) {
    console.error('Failed to suggest formation:', error);
    alert('Failed to suggest formation');
  }
}

function clearFormationDisplay() {
  ui.formationName.value = '';
  ui.formationType.value = '4-4-2';
  ui.formationDescription.value = '';
  ui.formationPositions.innerHTML = '';
  ui.formationInfo.textContent = 'No formation selected';
  ui.positionAssignments.innerHTML = '<div class="hint">Select a formation to assign players</div>';
}

/** -------------------------
 *  Boot
 *  ------------------------- */
function renderAll() {
  renderSetup();
  renderLineup();
  renderGame();
  renderReports();
  renderPlayers();
  renderFormations();
}
loadLocal();
renderAll();
show("setup");
startTick(); // keep countdown labels alive even when paused
</script>
</body>
</html>
